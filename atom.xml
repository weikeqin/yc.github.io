<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沧海一粟</title>
  
  <subtitle>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://weikeqin.com/"/>
  <updated>2020-08-09T13:39:48.567Z</updated>
  <id>http://weikeqin.com/</id>
  
  <author>
    <name>WKQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jvm-gc</title>
    <link href="http://weikeqin.com/2020/08/02/jvm-gc/"/>
    <id>http://weikeqin.com/2020/08/02/jvm-gc/</id>
    <published>2020-08-02T13:59:41.000Z</published>
    <updated>2020-08-09T13:39:48.567Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。这里便涉及了一个关键的问题：如何辨别一个对象是存是亡？</p><h1 id="如何判断对象已死"><a href="#如何判断对象已死" class="headerlink" title="如何判断对象已死"></a>如何判断对象已死</h1><h2 id="引用计数法（reference-counting）"><a href="#引用计数法（reference-counting）" class="headerlink" title="引用计数法（reference counting）"></a>引用计数法（reference counting）</h2><blockquote><p> 为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p></blockquote><blockquote><p> 具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。</p></blockquote><p>缺点:</p><ol><li>需要额外的空间来存储计数器，以及繁琐的更新操作。</li><li>有一个重大的漏洞，那便是无法处理循环引用对象。从而造成了内存泄露。</li></ol><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><blockquote><p> 将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p></blockquote><a id="more"></a><p>什么是 GC Roots 呢？我们可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：</p><ol><li>Java 方法栈桢中的局部变量；</li><li>已加载类的静态变量；</li><li>JNI handles；</li><li>已启动且未停止的 Java 线程。</li></ol><p>优点:</p><blockquote><p> 可达性分析可以解决引用计数法所不能解决的循环引用问题。<br> 举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，那么可达性分析便不会将它们加入存活对象合集之中。</p></blockquote><p>缺点: </p><blockquote><p> 在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。</p></blockquote><h3 id="如何解决可达性分析算法误报和漏报的问题"><a href="#如何解决可达性分析算法误报和漏报的问题" class="headerlink" title="如何解决可达性分析算法误报和漏报的问题"></a>如何解决可达性分析算法误报和漏报的问题</h3><p>  Stop-the-world 以及安全点</p><blockquote><p> 在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。</p></blockquote><blockquote><p> Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。</p></blockquote><p>无安全点检测的计数循环带来的长暂停<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time java SafepointTestp</span></span><br><span class="line">/ 你还可以使用如下几个选项</span><br><span class="line"><span class="comment">// -XX:+PrintGC</span></span><br><span class="line"><span class="comment">// -XX:+PrintGCApplicationStoppedTime </span></span><br><span class="line"><span class="comment">// -XX:+PrintSafepointStatistics</span></span><br><span class="line"><span class="comment">// -XX:+UseCountedLoopSafepoints</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafepointTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x77777777</span>; i++) &#123;</span><br><span class="line">      sum += Math.sqrt(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50_000_000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Object().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(SafepointTest::foo).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(SafepointTest::bar).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h1><h2 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h2><blockquote><p> 清除（sweep），即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p></blockquote><p>优点: 简单<br>缺点： </p><ol><li>会造成内存碎片。</li><li>分配效率低。 </li></ol><h2 id="压缩（compact）"><a href="#压缩（compact）" class="headerlink" title="压缩（compact）"></a>压缩（compact）</h2><p>把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p><h2 id="复制（copy）"><a href="#复制（copy）" class="headerlink" title="复制（copy）"></a>复制（copy）</h2><blockquote><p> 复制（copy），即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。</p></blockquote><p>统计 Java 对象生命周期的动态分析，并且用它来跑了一些基准测试。大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。</p><h1 id="JVM堆的划分"><a href="#JVM堆的划分" class="headerlink" title="JVM堆的划分"></a>JVM堆的划分</h1><blockquote><p> 统计 Java 对象生命周期的动态，会发现 <code>大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间</code>。<br> 它造就了 Java 虚拟机的分代回收思想。简单来说，就是将堆空间划分为两代，分别叫做新生代和老年代。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。</p></blockquote><p>Java 虚拟机可以给不同代使用不同的回收算法。</p><blockquote><p> 对于新生代，大部分的 Java 对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。</p></blockquote><blockquote><p> 对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。这时候，Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。</p></blockquote><blockquote><p> Java 虚拟机将堆划分为新生代和老年代。<br> 其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。<br> 默认情况下，Java 虚拟机采取的是一种动态分配的策略（对应 Java 虚拟机参数 -XX:+UsePSAdaptiveSurvivorSizePolicy），根据生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。</p></blockquote><p>通常来说，当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。</p><p>Java 虚拟机的解决方法是为每个司机预先申请多个停车位，并且只允许该司机停在自己的停车位上。<br>当司机的停车位用完了该怎么办呢（假设这个司机代客泊车）？答案是：再申请多个停车位便可以了。这项技术被称之为 TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）。</p><blockquote><p> 每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。</p></blockquote><p>当 Eden 区的空间耗尽了怎么办？这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。</p><p>Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。</p><p>Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是老年代的对象可能引用新生代的对象。</p><p>HotSpot 给出的解决方案是一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC </p><p>Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。</p><h1 id="JVM垃圾回收器"><a href="#JVM垃圾回收器" class="headerlink" title="JVM垃圾回收器"></a>JVM垃圾回收器</h1><p>针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。<br>这三个采用的都是标记 - 复制算法。<br>其中，Serial 是一个单线程的，<br>Parallel New 可以看成 Serial 的多线程版本。<br>Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。</p><p>针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。<br>Serial Old 和 Parallel Old 都是标记 - 压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。<br>CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。</p><p>由于 G1 的出现，CMS 在 Java 9 中已被废弃。G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。<br>它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。</p><p>Java 11 引入了 ZGC，宣称暂停时间不超过 10ms。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run with java -XX:+PrintGC -Xmn100M -XX:PretenureSizeThreshold=10000 LifetimeTest</span></span><br><span class="line"><span class="comment">// You may also try with -XX:+PrintHeapAtGC，-XX:-UsePSAdaptiveSurvivorSizePolicy or -XX:SurvivorRatio=N</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifetimeTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> K = <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = K * K;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> G = K * M;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALIVE_OBJECT_SIZE = <span class="number">32</span> * M;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = ALIVE_OBJECT_SIZE / <span class="number">64</span>;</span><br><span class="line">    ObjectOf64Bytes[] array = <span class="keyword">new</span> ObjectOf64Bytes[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; G; i++) &#123;</span><br><span class="line">      array[(<span class="keyword">int</span>) (i % length)] = <span class="keyword">new</span> ObjectOf64Bytes();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectOf64Bytes</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> placeholder0;</span><br><span class="line">  <span class="keyword">long</span> placeholder1;</span><br><span class="line">  <span class="keyword">long</span> placeholder2;</span><br><span class="line">  <span class="keyword">long</span> placeholder3;</span><br><span class="line">  <span class="keyword">long</span> placeholder4;</span><br><span class="line">  <span class="keyword">long</span> placeholder5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://time.geekbang.org/column/article/13091" target="_blank" rel="noopener">11 | 垃圾回收（上）</a><br>[2] <a href="https://time.geekbang.org/column/article/13137" target="_blank" rel="noopener">12 | 垃圾回收（下）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。这里便涉及了一个关键的问题：如何辨别一个对象是存是亡？&lt;/p&gt;
&lt;h1 id=&quot;如何判断对象已死&quot;&gt;&lt;a href=&quot;#如何判断对象已死&quot; class=&quot;headerlink&quot; title=&quot;如何判断对象已死&quot;&gt;&lt;/a&gt;如何判断对象已死&lt;/h1&gt;&lt;h2 id=&quot;引用计数法（reference-counting）&quot;&gt;&lt;a href=&quot;#引用计数法（reference-counting）&quot; class=&quot;headerlink&quot; title=&quot;引用计数法（reference counting）&quot;&gt;&lt;/a&gt;引用计数法（reference counting）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要额外的空间来存储计数器，以及繁琐的更新操作。&lt;/li&gt;
&lt;li&gt;有一个重大的漏洞，那便是无法处理循环引用对象。从而造成了内存泄露。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;可达性分析&quot;&gt;&lt;a href=&quot;#可达性分析&quot; class=&quot;headerlink&quot; title=&quot;可达性分析&quot;&gt;&lt;/a&gt;可达性分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://weikeqin.com/categories/jvm/"/>
    
    
      <category term="java" scheme="http://weikeqin.com/tags/java/"/>
    
      <category term="jvm" scheme="http://weikeqin.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>data-structure-linked-list</title>
    <link href="http://weikeqin.com/2020/07/18/data-structure-linked-list/"/>
    <id>http://weikeqin.com/2020/07/18/data-structure-linked-list/</id>
    <published>2020-07-18T09:15:22.000Z</published>
    <updated>2020-08-09T13:42:33.892Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] 《数据结构》(C语言版) 严蔚敏 吴伟民<br>[2] <a href="https://time.geekbang.org/column/article/41013" target="_blank" rel="noopener">06 | 链表（上）：如何实现LRU缓存淘汰算法?</a><br>[3] <a href="https://time.geekbang.org/column/article/41149" target="_blank" rel="noopener">07 | 链表（下）：如何轻松写出正确的链表代码？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;[1] 《数据结构》(C语言版) 严蔚敏
      
    
    </summary>
    
      <category term="data-structure" scheme="http://weikeqin.com/categories/data-structure/"/>
    
    
      <category term="data-structure" scheme="http://weikeqin.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://weikeqin.com/2020/07/18/data-structure-array/"/>
    <id>http://weikeqin.com/2020/07/18/data-structure-array/</id>
    <published>2020-07-18T00:57:35.000Z</published>
    <updated>2020-08-09T13:42:21.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p></blockquote><blockquote><p> 线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p></blockquote><blockquote><p> 连续的内存空间和相同类型的数据</p></blockquote><p>拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。<br>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：a[i]_address = base_address + i * data_type_size其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。</p><a id="more"></a><h1 id="数组的插入和删除"><a href="#数组的插入和删除" class="headerlink" title="数组的插入和删除"></a>数组的插入和删除</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><blockquote><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><blockquote><p> 如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p></blockquote><h3 id="删除的优化"><a href="#删除的优化" class="headerlink" title="删除的优化"></a>删除的优化</h3><blockquote><p> 在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢<br>数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p></blockquote><p>  这就是 JVM 标记清除垃圾回收算法的核心思想 </p><h1 id="为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？"><a href="#为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？" class="headerlink" title="为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？"></a>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</h1><blockquote><p> 从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p></blockquote><blockquote><p>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1]《数据结构》(C语言版) 严蔚敏 吴伟民<br>[2] <a href="https://time.geekbang.org/column/article/40961" target="_blank" rel="noopener">05 | 数组：为什么很多编程语言中数组都从0开始编号？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 连续的内存空间和相同类型的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。&lt;br&gt;计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：a[i]_address = base_address + i * data_type_size其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。&lt;/p&gt;
    
    </summary>
    
      <category term="data-structure" scheme="http://weikeqin.com/categories/data-structure/"/>
    
    
      <category term="data-structure" scheme="http://weikeqin.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 复杂度分析</title>
    <link href="http://weikeqin.com/2020/07/18/data-structure-complexity-analysis/"/>
    <id>http://weikeqin.com/2020/07/18/data-structure-complexity-analysis/</id>
    <published>2020-07-18T00:49:02.000Z</published>
    <updated>2020-07-18T09:08:52.056Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。</p></blockquote><h1 id="1-为什么需要复杂度分析"><a href="#1-为什么需要复杂度分析" class="headerlink" title="(1) 为什么需要复杂度分析"></a>(1) 为什么需要复杂度分析</h1><blockquote><p> 把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？</p><p> 这种评估算法执行效率的方法是正确的，叫事后统计法。但是，这种统计方法有非常大的局限性。</p><ol><li>测试结果非常依赖测试环境</li><li>测试结果受数据规模的影响很大</li></ol></blockquote><blockquote><p> 在大学刚学C语言的时候，老师交给我们一个任务，根据高斯公式计算π的值，分别精确到第六位、第七位、第八位 …，下课后直接在图书馆写代码计算，计算结果精确到第六位的时候特别快，刚点运行就计算完了，花费几ms，计算第七、八、九位也很快，不超过3s，但是精确到第十位的时候，运行了30s后，听到电脑风扇 呼呼 地响了。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   计算π</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    无穷级数法</span></span><br><span class="line"><span class="comment"> *      莱布尼兹级数：π/4 = 1- 1/3 + 1/5 - 1/7 + 1/9 … (收敛很慢)</span></span><br><span class="line"><span class="comment"> *      马青公式：π/4 = 4(1/5-(1/5)³/3+(1/5)^5/5-(1/5)^7/7+……)+(1/239-(1/239)³/3+(1/239)^5/5-(1/239)^7/7+……)(du收敛较快，每计zhi算一项可得到π的1.4位十进制精度)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   含圆周率的公式列表- 维基百科，自由的百科全书  zh.wikipedia.org › zh-hans › 含圆周率的公式列表   https://zh.wikipedia.org/zh-hans/%E5%90%AB%E5%9C%86%E5%91%A8%E7%8E%87%E7%9A%84%E5%85%AC%E5%BC%8F%E5%88%97%E8%A1%A8</span></span><br><span class="line"><span class="comment"> *  【并行计算】六种方法计算圆周率  http://littledva.cn/article-16/</span></span><br><span class="line"><span class="comment"> *   http://turner.faculty.swau.edu/mathematics/materialslibrary/pi/piforms.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Java小程序计算圆周率代码  http://www.uxys.com/html/JavaKfjs/20170911/15192.html</span></span><br><span class="line"><span class="comment"> *   π后100位的计算PI https://blog.csdn.net/zhanbiane/article/details/56488694</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weikeqin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-07-18 09:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePiApproximation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CalculatePiApproximation c = <span class="keyword">new</span> CalculatePiApproximation();</span><br><span class="line">        <span class="keyword">double</span> preciseCount = <span class="number">1E-10</span>;</span><br><span class="line">        c.caclPi1(preciseCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     利用公式 π/4 ≈ 1 - (1/3) + (1/5) - (1/7) + ... ，</span></span><br><span class="line"><span class="comment">     *     编写程序计算π的近似值，</span></span><br><span class="line"><span class="comment">     *     直到最后一项的绝对值小于0.000001</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       精确到小数点后几位</span></span><br><span class="line"><span class="comment">     *        1e-6 = 1 * 10^(-6)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    无穷级数法</span></span><br><span class="line"><span class="comment">     *      莱布尼兹级数：π/4 = 1- 1/3 + 1/5 - 1/7 + 1/9 … (收敛很慢)</span></span><br><span class="line"><span class="comment">     *      马青公式：π/4 = 4(1/5-(1/5)³/3+(1/5)^5/5-(1/5)^7/7+……)+(1/239-(1/239)³/3+(1/239)^5/5-(1/239)^7/7+……)(du收敛较快，每计zhi算一项可得到π的1.4位十进制精度)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preciseCount 精确到小数点后几位 1E-6</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">caclPi1</span><span class="params">(<span class="keyword">double</span> preciseCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> symbol = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前分数</span></span><br><span class="line">        <span class="keyword">double</span> term = -<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> pi = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Math.abs(term) &gt; preciseCount) &#123;</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1/1  1/3  1/5</span></span><br><span class="line">            term = <span class="number">1.0</span> * symbol / i;</span><br><span class="line">            <span class="comment">// 1 -1</span></span><br><span class="line">            symbol = -symbol;</span><br><span class="line">            <span class="comment">// 1 - 1/3 + 1/5 - 1/7</span></span><br><span class="line">            pi += term;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pi *= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"pi："</span> + pi);</span><br><span class="line">        System.out.println(<span class="string">"loop count："</span> + count);</span><br><span class="line">        System.out.println(<span class="string">"cost "</span> + (t2 - t1) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="keyword">return</span> pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="(2) 时间复杂度"></a>(2) 时间复杂度</h1><blockquote><p> 从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。</p></blockquote><blockquote><p> 所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两数之和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等差数列的求和</span></span><br><span class="line"><span class="comment"> * 公差为1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">seqSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++) &#123;</span><br><span class="line">            sum += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p></blockquote><blockquote><ol><li>只关注循环执行次数最多的一段代码</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ol></blockquote><h2 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h2><ol><li>O(1)</li><li>O(logn)、O(nlogn)</li><li>O(m+n)、O(m*n)</li></ol><h2 id="复杂度量级"><a href="#复杂度量级" class="headerlink" title="复杂度量级"></a>复杂度量级</h2><blockquote><p>O(1) 常数阶<br>O(logn) 对数阶<br>O(n) 线性阶<br>O(nlogn) 线性对数阶<br>O(n^2) 平方阶<br>O(n^3) 立方阶<br>O(n^k) k次方阶</p></blockquote><blockquote><p>O(2^n) 指数阶<br>O(n!)  阶乘阶</p></blockquote><blockquote><p> 对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p></blockquote><blockquote><p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。</p></blockquote><h1 id="3-空间复杂度"><a href="#3-空间复杂度" class="headerlink" title="(3) 空间复杂度"></a>(3) 空间复杂度</h1><blockquote><p> 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] memory1() &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 可以看到，申请了一个变量i的存储空间，并且申请了 arr的存储空间。但是它是常量阶的，跟数据规模 n 没有关系，所以空间复杂度是O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] memory2(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 可以看到，申请了一个变量i的存储空间，并且申请了 arr的存储空间。arr的大小和n有关系，所以空间复杂度是O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] memory3(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            arr[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 可以看到，申请了一个变量i的存储空间，并且申请了 arr的存储空间。arr的大小和n有关系，因为是两个循环，所以空间复杂度是O(n^2)</p></blockquote><blockquote><p> 空间复杂度就是 O(1)、O(n)、O(n^2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] 《算法基础》 Richard Neapolitan (作者) 贾洪峰 (译者)<br>[2] <a href="https://time.geekbang.org/column/article/40036" target="_blank" rel="noopener">03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</a><br>[3] <a href="https://time.geekbang.org/column/article/40447" target="_blank" rel="noopener">04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</a><br>[4] [算法的时间复杂度和空间复杂度-总结( <a href="https://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener">https://blog.csdn.net/zolalad/article/details/11848739</a> )</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-为什么需要复杂度分析&quot;&gt;&lt;a href=&quot;#1-为什么需要复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;(1) 为什么需要复杂度分析&quot;&gt;&lt;/a&gt;(1) 为什么需要复杂度分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？&lt;/p&gt;
&lt;p&gt; 这种评估算法执行效率的方法是正确的，叫事后统计法。但是，这种统计方法有非常大的局限性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测试结果非常依赖测试环境&lt;/li&gt;
&lt;li&gt;测试结果受数据规模的影响很大&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 在大学刚学C语言的时候，老师交给我们一个任务，根据高斯公式计算π的值，分别精确到第六位、第七位、第八位 …，下课后直接在图书馆写代码计算，计算结果精确到第六位的时候特别快，刚点运行就计算完了，花费几ms，计算第七、八、九位也很快，不超过3s，但是精确到第十位的时候，运行了30s后，听到电脑风扇 呼呼 地响了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="data-structure" scheme="http://weikeqin.com/categories/data-structure/"/>
    
    
      <category term="data-structure" scheme="http://weikeqin.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>jvm Opcode助记符</title>
    <link href="http://weikeqin.com/2020/07/05/java-virtual-machine-opcode-mnemonics-by-opcode/"/>
    <id>http://weikeqin.com/2020/07/05/java-virtual-machine-opcode-mnemonics-by-opcode/</id>
    <published>2020-07-05T15:32:09.000Z</published>
    <updated>2020-07-12T15:34:27.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-7.html" target="_blank" rel="noopener">Chapter 7. Opcode Mnemonics by Opcode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;[1] &lt;a href=&quot;https://docs.oracle.com/j
      
    
    </summary>
    
      <category term="jvm" scheme="http://weikeqin.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://weikeqin.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM指令集</title>
    <link href="http://weikeqin.com/2020/07/05/java-virtual-machine-instruction-set/"/>
    <id>http://weikeqin.com/2020/07/05/java-virtual-machine-instruction-set/</id>
    <published>2020-07-05T15:27:58.000Z</published>
    <updated>2020-07-12T15:30:29.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">The Java Virtual Machine Instruction Set</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;[1] &lt;a href=&quot;https://docs.oracle.com/j
      
    
    </summary>
    
      <category term="jvm" scheme="http://weikeqin.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://weikeqin.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm 加载 解析 初始化 类文件</title>
    <link href="http://weikeqin.com/2020/07/05/java-virtual-machine-loads-links-initializes/"/>
    <id>http://weikeqin.com/2020/07/05/java-virtual-machine-loads-links-initializes/</id>
    <published>2020-07-05T15:25:06.000Z</published>
    <updated>2020-07-12T15:27:07.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a><br>[2] <a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;[1] &lt;a href=&quot;https://docs.oracle.com/j
      
    
    </summary>
    
      <category term="jvm" scheme="http://weikeqin.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://weikeqin.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm类文件格式</title>
    <link href="http://weikeqin.com/2020/07/05/java-virtual-machine-class-file-format/"/>
    <id>http://weikeqin.com/2020/07/05/java-virtual-machine-class-file-format/</id>
    <published>2020-07-05T15:22:06.000Z</published>
    <updated>2020-07-12T15:23:39.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">Chapter 4. The class File Format</a><br>[2] <a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html" target="_blank" rel="noopener">Chapter 4. The class File Format</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;[1] &lt;a href=&quot;https://docs.oracle.com/j
      
    
    </summary>
    
      <category term="jvm" scheme="http://weikeqin.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://weikeqin.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM编译</title>
    <link href="http://weikeqin.com/2020/07/05/java-virtual-machine-compiling/"/>
    <id>http://weikeqin.com/2020/07/05/java-virtual-machine-compiling/</id>
    <published>2020-07-05T15:18:30.000Z</published>
    <updated>2020-07-12T15:21:30.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] [Chapter 3. Compiling for the Java Virtual Machine] ( <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html</a> )<br>[2] [Chapter 3. Compiling for the Java Virtual Machine] ( <a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-3.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-3.html</a> )</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;[1] [Chapter 3. Compiling for the Java
      
    
    </summary>
    
      <category term="jvm" scheme="http://weikeqin.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://weikeqin.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机结构</title>
    <link href="http://weikeqin.com/2020/07/05/java-virtual-machine-structure/"/>
    <id>http://weikeqin.com/2020/07/05/java-virtual-machine-structure/</id>
    <published>2020-07-04T23:43:14.000Z</published>
    <updated>2020-08-05T11:58:53.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> The Structure of the Java Virtual Machine</p><ol><li>The class File Format</li><li>Data Types</li><li>Primitive Types and Values</li><li>Reference Types and Values</li><li>Run-Time Data Areas</li><li>Frames</li><li>Representation of Objects</li><li>Floating-Point Arithmetic</li><li>Special Methods</li><li>Exceptions</li><li>Instruction Set Summary</li><li>Class Libraries</li><li>Public Design, Private Implementation</li></ol></blockquote><p>　　本文档指定了一台抽象机器。它没有描述Java虚拟机的任何特定实现。</p><p>　　要正确实现Java虚拟机，您只需要能够读取类文件格式并正确执行其中指定的操作。不属于Java虚拟机规范的实现细节将不必要地限制实现者的创造力。例如，运行时数据区域的内存布局、使用的垃圾收集算法以及Java虚拟机指令的任何内部优化（例如，将它们转换为机器代码）都由实现者自行决定。</p><p>　　本规范中对Unicode的所有引用都是针对Unicode标准6.0.0版提供的，可从<a href="http://www.unicode.org/。" target="_blank" rel="noopener">http://www.unicode.org/。</a></p><a id="more"></a><blockquote><p> this document specifies an abstract machine. It does not describe any particular implementation of the Java Virtual Machine.</p></blockquote><blockquote><p> To implement the Java Virtual Machine correctly, you need only be able to read the class file format and correctly perform the operations specified therein. Implementation details that are not part of the Java Virtual Machine’s specification would unnecessarily constrain the creativity of implementors. For example, the memory layout of run-time data areas, the garbage-collection algorithm used, and any internal optimization of the Java Virtual Machine instructions (for example, translating them into machine code) are left to the discretion of the implementor.</p></blockquote><blockquote><p> All references to Unicode in this specification are given with respect to The Unicode Standard, Version 6.0.0, available at <a href="http://www.unicode.org/" target="_blank" rel="noopener">http://www.unicode.org/</a>.</p></blockquote><p><br><br></p><h1 id="1-类文件格式-The-class-File-Format"><a href="#1-类文件格式-The-class-File-Format" class="headerlink" title="(1) 类文件格式 (The class File Format)"></a>(1) 类文件格式 (The class File Format)</h1><p>　　Java虚拟机执行的编译代码使用独立于硬件和操作系统的二进制格式表示，通常（但不一定）存储在一个文件中，称为类文件格式。类文件格式精确地定义了类或接口的表示，包括在特定于平台的对象文件格式中可能被视为理所当然的详细信息。</p><blockquote><p> Compiled code to be executed by the Java Virtual Machine is represented using a hardware- and operating system-independent binary format, typically (but not necessarily) stored in a file, known as the class file format. The class file format precisely defines the representation of a class or interface, including details such as byte ordering that might be taken for granted in a platform-specific object file format.</p></blockquote><p><br><br></p><h1 id="2-数据类型-Data-Types"><a href="#2-数据类型-Data-Types" class="headerlink" title="(2) 数据类型 (Data Types)"></a>(2) 数据类型 (Data Types)</h1><p>　　与Java编程语言一样，Java虚拟机操作两种类型：<code>基本类型</code> 和 <code>引用类型</code> 。相应地，有两种值可以存储在变量中，作为参数传递，由方法返回并对其进行操作：原始值和引用值。</p><p>　　Java虚拟机希望几乎所有类型检查都是在运行时之前完成的，通常是由编译器完成的，而不必由Java虚拟机本身完成。基本类型的值不需要标记，也不需要进行检查，以便在运行时确定它们的类型，或者与引用类型的值区分开来。相反，Java虚拟机的指令集使用旨在对特定类型的值进行操作的指令来区分其操作数类型。例如，iadd、ladd、fadd和dadd都是Java虚拟机指令，它们将两个数值相加并生成数值结果，但每种指令都针对其操作数类型进行了专门化：int、long、float和double。有关Java虚拟机指令集中类型支持的摘要，请参见§2.11.1。</p><p>　　Java虚拟机包含对对象的显式支持。对象可以是动态分配的类实例或数组。对对象的引用被认为具有Java虚拟机类型引用。类型引用的值可以看作是指向对象的指针。可能存在对一个对象的多个引用。对象总是通过类型引用的值进行操作、传递和测试。</p><blockquote><p> Like the Java programming language, the Java Virtual Machine operates on two kinds of types: primitive types and reference types. There are, correspondingly, two kinds of values that can be stored in variables, passed as arguments, returned by methods, and operated upon: primitive values and reference values.</p></blockquote><blockquote><p> The Java Virtual Machine expects that nearly all type checking is done prior to run time, typically by a compiler, and does not have to be done by the Java Virtual Machine itself. Values of primitive types need not be tagged or otherwise be inspectable to determine their types at run time, or to be distinguished from values of reference types. Instead, the instruction set of the Java Virtual Machine distinguishes its operand types using instructions intended to operate on values of specific types. For instance, iadd, ladd, fadd, and dadd are all Java Virtual Machine instructions that add two numeric values and produce numeric results, but each is specialized for its operand type: int, long, float, and double, respectively. For a summary of type support in the Java Virtual Machine instruction set, see §2.11.1.</p></blockquote><blockquote><p> The Java Virtual Machine contains explicit support for objects. An object is either a dynamically allocated class instance or an array. A reference to an object is considered to have Java Virtual Machine type reference. Values of type reference can be thought of as pointers to objects. More than one reference to an object may exist. Objects are always operated on, passed, and tested via values of type reference.</p></blockquote><p><br><br></p><h1 id="3-基本类型和值-Primitive-Types-and-Values"><a href="#3-基本类型和值-Primitive-Types-and-Values" class="headerlink" title="(3) 基本类型和值 (Primitive Types and Values)"></a>(3) 基本类型和值 (Primitive Types and Values)</h1><p>　　Java虚拟机支持的基本数据类型是　数字类型、布尔类型（§2.3.4）和returnAddress类型（§2.3.3）。<br>　　数字类型包括整数类型（§2.3.1）和浮点类型（§2.3.2）。<br>　　　　整数类型有：<br>　　　　　byte，其值为8位带符号的两个补码整数，其默认值为零<br>　　　　　short，其值为16位带符号的两个补整数，其默认值为零<br>　　　　　int，其值为32位带符号的两个补整数，其默认值为零<br>　　　　　long，其值为64位带符号的两个补整数，其默认值为零<br>　　　　　char，其值为16位无符号整数，表示基本多语言平面中的Unicode码位，用UTF-16编码，其默认值为空码位（’\u0000’）<br>　　　　浮点类型包括：<br>　　　　　float，其值是float值集的元素，或者在支持的情况下，是float扩展指数值集的元素，其默认值为正零<br>　　　　　double，其值是double值集的元素，或者在支持的情况下，是double扩展指数值集的元素，其默认值为正零<br>　　布尔类型的值编码真值true和false，默认值为false。</p><p>Java®虚拟机规范的第一版没有将boolean视为Java虚拟机类型。但是，布尔值在Java虚拟机中的支持是有限的。Java®虚拟机规范的第二版通过将布尔值作为一种类型来澄清这个问题。</p><p>　　returnAddress类型的值是指向Java虚拟机指令操作码的指针。在原语类型中，只有returnAddress类型与Java编程语言类型没有直接关联。</p><h2 id="3-1-Integral-Types-and-Values"><a href="#3-1-Integral-Types-and-Values" class="headerlink" title="(3.1)  (Integral Types and Values)"></a>(3.1)  (Integral Types and Values)</h2><p>　Java虚拟机的整型值为：</p><p>| Integral Types | Values                                      | remark             | 两边是否包括在内 |<br>| byte           | -128 ~ 127                                  |  -2^7  ~ 2^7 - 1   | 包括 |<br>| short          | -32768 ~ 32767                              |  -2^15 ~ 2^15 - 1  | 包括 |<br>| int            | -2147483648 ~ 2147483647                    |  -2^31 ~ 2^31 - 1  | 包括 |<br>| long           | -9223372036854775808 ~ 9223372036854775807  |  -2^63 ~ 2^63 - 1  | 包括 |<br>| char           | 0 ~ 65535                                   |  0 ~ 2^16 - 1      | 包括 | </p><h2 id="3-2-Floating-Point-Types-Value-Sets-and-Values"><a href="#3-2-Floating-Point-Types-Value-Sets-and-Values" class="headerlink" title="3.2. Floating-Point Types, Value Sets, and Values"></a>3.2. Floating-Point Types, Value Sets, and Values</h2><p>　　浮点类型是float和double，它们在概念上与IEEE二进制浮点运算标准（ANSI/IEEE Std.754-1985，纽约）中规定的32位单精度和64位双精度格式IEEE 754值和操作相关联。</p><p>　　ieee754标准不仅包括正负号量值，还包括正负零、正负无穷大，以及一个特殊的非数字值（以下简称为“NaN”）。NaN值用于表示某些无效操作（例如零除以零）的结果。</p><p>The floating-point types are float and double, which are conceptually associated with the 32-bit single-precision and 64-bit double-precision format IEEE 754 values and operations as specified in IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std. 754-1985, New York).</p><p>The IEEE 754 standard includes not only positive and negative sign-magnitude numbers, but also positive and negative zeros, positive and negative infinities, and a special Not-a-Number value (hereafter abbreviated as “NaN”). The NaN value is used to represent the result of certain invalid operations such as dividing zero by zero.</p><h2 id="3-3-The-returnAddress-Type-and-Values"><a href="#3-3-The-returnAddress-Type-and-Values" class="headerlink" title="3.3 The returnAddress Type and Values"></a>3.3 The returnAddress Type and Values</h2><p>　　returnAddress类型由Java虚拟机的jsr、ret和jsr zu w指令（§jsr、§ret、§jsrĩw）使用。returnAddress类型的值是指向Java虚拟机指令操作码的指针。与数字原语类型不同，returnAddress类型与任何Java编程语言类型都不对应，并且运行的程序无法对其进行修改。</p><blockquote><p> The returnAddress type is used by the Java Virtual Machine’s jsr, ret, and jsr_w instructions (§jsr, §ret, §jsr_w). The values of the returnAddress type are pointers to the opcodes of Java Virtual Machine instructions. Unlike the numeric primitive types, the returnAddress type does not correspond to any Java programming language type and cannot be modified by the running program.</p></blockquote><h2 id="3-4-The-boolean-Type"><a href="#3-4-The-boolean-Type" class="headerlink" title="3.4. The boolean Type"></a>3.4. The boolean Type</h2><p>　　尽管Java虚拟机定义了一个布尔类型，但它只提供非常有限的支持。没有专门用于布尔值操作的Java虚拟机指令。相反，Java编程语言中对布尔值进行操作的表达式被编译为使用Java虚拟机int数据类型的值。</p><p>　　Java虚拟机直接支持布尔数组。它的newarray指令（§newarray）允许创建布尔数组。使用字节数组指令baload和bastore（§baload，§bastore）访问和修改boolean类型的数组。</p><p>　　在Oracle的Java虚拟机实现中，Java编程语言中的布尔数组被编码为Java虚拟机字节数组，每个布尔元素使用8位。</p><p>　　Java虚拟机对布尔数组组件进行编码，使用1表示真，0表示假。当编译器将Java编程语言布尔值映射到Java虚拟机类型int的值时，编译器必须使用相同的编码。</p><blockquote><p> Although the Java Virtual Machine defines a boolean type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on boolean values. Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine int data type.</p></blockquote><blockquote><p> The Java Virtual Machine does directly support boolean arrays. Its newarray instruction (§newarray) enables creation of boolean arrays. Arrays of type boolean are accessed and modified using the byte array instructions baload and bastore (§baload, §bastore).</p></blockquote><blockquote><p> In Oracle’s Java Virtual Machine implementation, boolean arrays in the Java programming language are encoded as Java Virtual Machine byte arrays, using 8 bits per boolean element.</p></blockquote><blockquote><p> The Java Virtual Machine encodes boolean array components using 1 to represent true and 0 to represent false. Where Java program</p></blockquote><p><br><br></p><h1 id="4-引用类型和值-Reference-Types-and-Values"><a href="#4-引用类型和值-Reference-Types-and-Values" class="headerlink" title="4. 引用类型和值 ( Reference Types and Values )"></a>4. 引用类型和值 ( Reference Types and Values )</h1><blockquote><p> 有三种引用类型：类类型，数组类型和接口类型。它们的值分别引用动态创建的类实例，数组或实现接口的类实例或数组。</p></blockquote><blockquote><p> 数组类型由具有单个维度的组件类型组成（其长度未由类型指定）。数组类型的组件类型本身可以是数组类型。如果从任何数组类型开始，先考虑其组件类型，然后再考虑（如果也是数组类型）该类型的组件类型，依此类推，则最终必须达到不是数组类型的组件类型；这称为数组类型的元素类型。数组类型的元素类型必须是原始类型，类类型或接口类型。</p></blockquote><blockquote><p> 引用值也可以是特殊的空引用，即无对象的引用，此处将以空表示。空引用最初没有运行时类型，但可以强制转换为任何类型。引用类型的默认值为null。</p></blockquote><blockquote><p> 本规范不要求编码为null的具体值。</p></blockquote><blockquote><p> There are three kinds of reference types: class types, array types, and interface types. Their values are references to dynamically created class instances, arrays, or class instances or arrays that implement interfaces, respectively.</p></blockquote><blockquote><p> An array type consists of a component type with a single dimension (whose length is not given by the type). The component type of an array type may itself be an array type. If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the element type of the array type. The element type of an array type is necessarily either a primitive type, or a class type, or an interface type.</p></blockquote><blockquote><p> A reference value may also be the special null reference, a reference to no object, which will be denoted here by null. The null reference initially has no run-time type, but may be cast to any type. The default value of a reference type is null.</p></blockquote><blockquote><p> This specification does not mandate a concrete value encoding null.</p></blockquote><p><br></p><h1 id="5-运行时数据区域-Run-Time-Data-Areas"><a href="#5-运行时数据区域-Run-Time-Data-Areas" class="headerlink" title="5. 运行时数据区域 ( Run-Time Data Areas )"></a>5. 运行时数据区域 ( Run-Time Data Areas )</h1><h2 id="5-1-pc计数器-The-pc-Register"><a href="#5-1-pc计数器-The-pc-Register" class="headerlink" title="5.1  pc计数器 ( The pc Register )"></a>5.1  pc计数器 ( The pc Register )</h2><blockquote><p> Java虚拟机同一时刻可以支持许多执行线程。 每个Java虚拟机线程都有其自己的pc（程序计数器）寄存器。 在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法。 如果该方法不是native方法，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。 如果线程当前正在执行的方法是native方法，则Java虚拟机的pc寄存器的值是undefined。 Java虚拟机的pc寄存器足够宽，可以在特定平台上保存returnAddress或本机指针。</p></blockquote><blockquote><p> The Java Virtual Machine can support many threads of execution at once . Each Java Virtual Machine thread has its own pc (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method for that thread. If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is native, the value of the Java Virtual Machine’s pc register is undefined. The Java Virtual Machine’s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.</p></blockquote><h2 id="5-2-JVM栈-Java-Virtual-Machine-Stacks"><a href="#5-2-JVM栈-Java-Virtual-Machine-Stacks" class="headerlink" title="5.2 JVM栈 Java Virtual Machine Stacks"></a>5.2 JVM栈 Java Virtual Machine Stacks</h2><p>Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread. A Java Virtual Machine stack stores frames . A Java Virtual Machine stack is analogous to the stack of a conventional language such as C: it holds local variables and partial results, and plays a part in method invocation and return. Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated. The memory for a Java Virtual Machine stack does not need to be contiguous.</p><p>In the First Edition of The Java® Virtual Machine Specification, the Java Virtual Machine stack was known as the Java stack.</p><p>This specification permits Java Virtual Machine stacks either to be of a fixed size or to dynamically expand and contract as required by the computation. If the Java Virtual Machine stacks are of a fixed size, the size of each Java Virtual Machine stack may be chosen independently when that stack is created.</p><p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of Java Virtual Machine stacks, as well as, in the case of dynamically expanding or contracting Java Virtual Machine stacks, control over the maximum and minimum sizes.</p><p>The following exceptional conditions are associated with Java Virtual Machine stacks:</p><p>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError.</p><p>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html" target="_blank" rel="noopener">Chapter 2. The Structure of the Java Virtual Machine</a><br>[2] <a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-2.html" target="_blank" rel="noopener">Chapter 2. The Structure of the Java Virtual Machine</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; The Structure of the Java Virtual Machine&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The class File Format&lt;/li&gt;
&lt;li&gt;Data Types&lt;/li&gt;
&lt;li&gt;Primitive Types and Values&lt;/li&gt;
&lt;li&gt;Reference Types and Values&lt;/li&gt;
&lt;li&gt;Run-Time Data Areas&lt;/li&gt;
&lt;li&gt;Frames&lt;/li&gt;
&lt;li&gt;Representation of Objects&lt;/li&gt;
&lt;li&gt;Floating-Point Arithmetic&lt;/li&gt;
&lt;li&gt;Special Methods&lt;/li&gt;
&lt;li&gt;Exceptions&lt;/li&gt;
&lt;li&gt;Instruction Set Summary&lt;/li&gt;
&lt;li&gt;Class Libraries&lt;/li&gt;
&lt;li&gt;Public Design, Private Implementation&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　本文档指定了一台抽象机器。它没有描述Java虚拟机的任何特定实现。&lt;/p&gt;
&lt;p&gt;　　要正确实现Java虚拟机，您只需要能够读取类文件格式并正确执行其中指定的操作。不属于Java虚拟机规范的实现细节将不必要地限制实现者的创造力。例如，运行时数据区域的内存布局、使用的垃圾收集算法以及Java虚拟机指令的任何内部优化（例如，将它们转换为机器代码）都由实现者自行决定。&lt;/p&gt;
&lt;p&gt;　　本规范中对Unicode的所有引用都是针对Unicode标准6.0.0版提供的，可从&lt;a href=&quot;http://www.unicode.org/。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.unicode.org/。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://weikeqin.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://weikeqin.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>mysql-log</title>
    <link href="http://weikeqin.com/2020/06/28/mysql-log/"/>
    <id>http://weikeqin.com/2020/06/28/mysql-log/</id>
    <published>2020-06-28T01:25:22.000Z</published>
    <updated>2020-07-12T14:17:06.422Z</updated>
    
    <content type="html"><![CDATA[<p>  redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；<br>  binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p><p>  Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。<br>  Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。(row格式会导致日志变大)</p><p>  binlog是可以关的，你如果有权限，可以set sql_log_bin=0关掉本线程的binlog日志。 所以只依赖binlog来恢复就靠不住。</p><p>  innodb B+树主键索引的叶子节点存的是什么，存的是页<br>  B+树的叶子节点是page （页），一个页里面可以存多个行 </p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://time.geekbang.org/column/article/68633" target="_blank" rel="noopener">02 | 日志系统：一条SQL更新语句是如何执行的？</a><br>[2] <a href="https://www.cnblogs.com/f-ck-need-u/p/9010872.html" target="_blank" rel="noopener">详细分析MySQL事务日志(redo log和undo log)</a><br>[3] <a href="https://www.cnblogs.com/f-ck-need-u/p/9001061.html" target="_blank" rel="noopener">详细分析MySQL的日志(一)</a><br>[4] <a href="https://dev.mysql.com/doc/refman/5.7/en/server-logs.html" target="_blank" rel="noopener">dev.mysql.com/doc/refman/5.7/en/server-logs.html</a><br>[5] <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html" target="_blank" rel="noopener">dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；&lt;br&gt;  binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。&lt;/p&gt;
&lt;p&gt;  Redo log不是记录数据页“更新之后的状态”，而是记录这个页
      
    
    </summary>
    
      <category term="mysql" scheme="http://weikeqin.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://weikeqin.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>全局唯一ID 分布式ID</title>
    <link href="http://weikeqin.com/2020/06/21/unique-id/"/>
    <id>http://weikeqin.com/2020/06/21/unique-id/</id>
    <published>2020-06-21T09:14:18.000Z</published>
    <updated>2020-07-12T14:18:40.165Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是分布式ID</strong></p><blockquote><p> 在我们系统数据量不大的时候，单库单表完全可以支撑现有系统，数据再大一点搞个MySQL主从同步读写分离也能对付。<br>但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。那么这个全局唯一ID就叫分布式ID。</p></blockquote><p><strong>分布式ID需要满足那些条件</strong><br>全局唯一：必须保证ID是全局性唯一的，基本要求<br>高性能：高可用低延时，ID生成响应要块，否则反倒会成为瓶颈<br>高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性<br>好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单<br>趋势递增：最好趋势递增，这个要求就得看具体场景了，一般不严格要求</p><p><strong>有哪些生成方式</strong></p><p>程序自增ID<br>关系型数据库自增ID<br>Redis</p><p>UUID</p><p>数据库多主模式<br>号段模式</p><p>雪花算法（SnowFlake）<br>滴滴出品（TinyID）<br>百度 （Uidgenerator）<br>美团（Leaf）</p><a id="more"></a><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MzAxNTM4NzAyNg%3D%3D&amp;mid=2247483785&amp;idx=1&amp;sn=8b828a8ae1701b810fe3969be536cb14&amp;scene=45#wechat_redirect" target="_blank" rel="noopener">一口气说出 9种 分布式ID生成方式，面试官有点懵了</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;什么是分布式ID&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 在我们系统数据量不大的时候，单库单表完全可以支撑现有系统，数据再大一点搞个MySQL主从同步读写分离也能对付。&lt;br&gt;但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。那么这个全局唯一ID就叫分布式ID。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;分布式ID需要满足那些条件&lt;/strong&gt;&lt;br&gt;全局唯一：必须保证ID是全局性唯一的，基本要求&lt;br&gt;高性能：高可用低延时，ID生成响应要块，否则反倒会成为瓶颈&lt;br&gt;高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性&lt;br&gt;好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单&lt;br&gt;趋势递增：最好趋势递增，这个要求就得看具体场景了，一般不严格要求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有哪些生成方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序自增ID&lt;br&gt;关系型数据库自增ID&lt;br&gt;Redis&lt;/p&gt;
&lt;p&gt;UUID&lt;/p&gt;
&lt;p&gt;数据库多主模式&lt;br&gt;号段模式&lt;/p&gt;
&lt;p&gt;雪花算法（SnowFlake）&lt;br&gt;滴滴出品（TinyID）&lt;br&gt;百度 （Uidgenerator）&lt;br&gt;美团（Leaf）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jvm-notes</title>
    <link href="http://weikeqin.com/2020/06/21/jvm-notes/"/>
    <id>http://weikeqin.com/2020/06/21/jvm-notes/</id>
    <published>2020-06-21T03:25:34.000Z</published>
    <updated>2020-07-26T02:50:13.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> Java虚拟机是Java平台的基石。它是技术的组成部分，负责硬件和操作系统的独立性，编译代码的小巧大小以及保护用户免受恶意程序侵害的能力。</p></blockquote><blockquote><p> Java虚拟机是抽象的计算机。像真正的计算机一样，它具有指令集，并在运行时操作各种内存区域。使用虚拟机实现编程语言是相当普遍的。最知名的虚拟机可能是UCSD Pascal的P代码计算机。</p></blockquote><blockquote><p> Java虚拟机对Java编程语言一无所知，仅对特定的二进制格式（class文件格式）一无所知。一个class文件包含的Java虚拟机指令（或字节码）和符号表，以及其它辅助信息。</p></blockquote><blockquote><p> 为了安全起见，Java虚拟机对class文件中的代码施加了严格的语法和结构约束。但是，classJava虚拟机可以托管任何可以用有效文件表示的功能的语言。受通用的，独立于机器的平台的吸引，其他语言的实现者可以将Java虚拟机用作其语言的交付工具。</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>  <a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a><br>  <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a><br>  <a href="https://github.com/deephacks/awesome-jvm" target="_blank" rel="noopener">https://github.com/deephacks/awesome-jvm</a><br>  <a href="https://github.com/graalvm/graal-jvmci-8" target="_blank" rel="noopener">https://github.com/graalvm/graal-jvmci-8</a><br>  <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javap.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javap.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; Java虚拟机是Java平台的基石。它是技术的组成部分，负责硬件和操作系统的独立性，编译代码的小巧大小以及保护用户免受恶意程序侵害的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Java虚拟机是抽象的计算机。像真正
      
    
    </summary>
    
      <category term="jvm" scheme="http://weikeqin.com/categories/jvm/"/>
    
    
      <category term="java" scheme="http://weikeqin.com/tags/java/"/>
    
      <category term="jvm" scheme="http://weikeqin.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>io-model</title>
    <link href="http://weikeqin.com/2020/06/17/io-model/"/>
    <id>http://weikeqin.com/2020/06/17/io-model/</id>
    <published>2020-06-17T15:46:45.000Z</published>
    <updated>2020-06-22T09:10:58.172Z</updated>
    
    <content type="html"><![CDATA[<p>网络通信中，最底层的就是内核中的网络 I/O 模型了。</p><blockquote><p> 随着技术的发展，操作系统内核的网络模型衍生出了五种 I/O 模型，《UNIX 网络编程》一书将这五种 I/O 模型分为 <code>阻塞式 I/O</code>、<code>非阻塞式 I/O</code>、<code>I/O 复用</code>、<code>信号驱动式 I/O</code> 和 <code>异步 I/O</code>。每一种 I/O 模型的出现，都是基于前一种 I/O 模型的优化升级。</p></blockquote><a id="more"></a><p>同步：调用端会一直等待服务端响应，直到返回结果。<br>异步：调用端发起调用之后不会立刻返回，不会等待服务端响应。服务端通过通知机制或者回调函数来通知客户端。<br>阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被CPU调度，线程暂停运行。<br>非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回。</p><p><strong>核心态(Kernel model)和用户态(User model)</strong><br>核心态(Kernel model)和用户态(User model)，CPU会在两个model之间切换。</p><p>核心态代码拥有完全的底层资源控制权限，可以执行任何CPU指令，访问任何内存地址，其占有的处理机是不允许被抢占的。内核态的指令包括：启动I/O，内存清零，修改程序状态字，设置时钟，允许/终止中断和停机。内核态的程序崩溃会导致PC停机。<br>用户态是用户程序能够使用的指令，不能直接访问底层硬件和内存地址。用户态运行的程序必须委托系统调用来访问硬件和内存。用户态的指令包括：控制转移，算数运算，取数指令，访管指令（使用户程序从用户态陷入内核态）。</p><p><strong>进程切换</strong></p><blockquote><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><blockquote><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol></blockquote></blockquote><p><strong>进程阻塞</strong></p><blockquote><p> 正在执行的进程由于一些事情发生，如请求资源失败、等待某种操作完成、新数据尚未达到或者没有新工作做等，由系统自动执行阻塞原语，使进程状态变为阻塞状态。因此，进程阻塞是进程自身的一种主动行为，只有处于运行中的进程才可以将自身转化为阻塞状态。当进程被阻塞，它是不占用CPU资源的。</p></blockquote><p><strong>文件描述符(fd, File Descriptor)</strong></p><blockquote><p> FD用于描述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p></blockquote><h1 id="1-阻塞式-I-O-blocking-IO"><a href="#1-阻塞式-I-O-blocking-IO" class="headerlink" title="(1) 阻塞式 I/O ( blocking IO )"></a>(1) 阻塞式 I/O ( blocking IO )</h1><blockquote><p> 在每一个连接创建时，都需要一个用户线程来处理，并且在 I/O 操作没有就绪或结束时，线程会被挂起，进入阻塞等待状态。<br> 在整个 socket 通信工作流程中，socket 的默认状态是阻塞的。也就是说，当发出一个不能立即完成的套接字调用时，其进程将被阻塞，被系统挂起，进入睡眠状态，一直等待相应的操作响应。<br> 阻塞式 I/O 就成为了导致性能瓶颈的根本原因。</p></blockquote><p><strong>connect 阻塞</strong></p><blockquote><p> connect 阻塞： 当客户端发起 TCP 连接请求，通过系统调用 connect 函数，TCP 连接的建立需要完成三次握手过程，客户端需要等待服务端发送回来的 ACK 以及 SYN 信号，同样服务端也需要阻塞等待客户端确认连接的 ACK 信号，这就意味着 TCP 的每个 connect 都会阻塞等待，直到确认连接。</p></blockquote><p><strong>accept 阻塞</strong></p><blockquote><p> accept 阻塞 : 一个阻塞的 socket 通信的服务端接收外来连接，会调用 accept 函数，如果没有新的连接到达，调用进程将被挂起，进入阻塞状态。</p></blockquote><p><strong>read、write 阻塞</strong></p><blockquote><p> read、write 阻塞 : 当一个 socket 连接创建成功之后，服务端用 fork 函数创建一个子进程， 调用 read 函数等待客户端的数据写入，如果没有数据写入，调用子进程将被挂起，进入阻塞状态。</p></blockquote><h1 id="2-非阻塞式-I-O-non-blocking-IO"><a href="#2-非阻塞式-I-O-non-blocking-IO" class="headerlink" title="(2) 非阻塞式 I/O ( non-blocking IO )"></a>(2) 非阻塞式 I/O ( non-blocking IO )</h1><blockquote><p> 非阻塞式I/O 解决了阻塞的问题。</p></blockquote><blockquote><p> 内核在没有准备好数据的时候会返回错误码，而调用程序不会休眠，而是不断轮询询问内核数据是否准备好。数据准备好时，函数成功返回。</p></blockquote><p>  使用用户线程轮询查看一个 I/O 操作的状态，在大量请求的情况下，非阻塞式IO的轮询会耗费大量cpu。</p><h1 id="3-I-O-复用"><a href="#3-I-O-复用" class="headerlink" title="(3) I/O 复用"></a>(3) I/O 复用</h1><blockquote><p> 类似与非阻塞，只不过轮询不是由用户线程去执行，而是由内核去轮询，内核监听程序监听到数据准备好后，调用内核函数复制数据到用户态。</p></blockquote><blockquote><p> Linux 提供了 I/O 复用函数 select/poll/epoll，进程将一个或多个读操作通过系统调用函数，阻塞在函数操作上。这样，系统内核就可以帮我们侦测多个读操作是否处于就绪状态。</p></blockquote><p>  Linux 提供了 I/O 复用函数 select/poll/epoll，进程将一个或多个读操作通过系统调用函数，阻塞在函数操作上。这样，系统内核就可以帮我们侦测多个读操作是否处于就绪状态。</p><h1 id="4-信号驱动式I-O（-signal-driven-IO-）"><a href="#4-信号驱动式I-O（-signal-driven-IO-）" class="headerlink" title="(4) 信号驱动式I/O（ signal-driven IO ）"></a>(4) 信号驱动式I/O（ signal-driven IO ）</h1><blockquote><p> 首先我们允许Socket进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p></blockquote><h1 id="5-异步非阻塞-I-O（-asynchronous-IO-）"><a href="#5-异步非阻塞-I-O（-asynchronous-IO-）" class="headerlink" title="(5) 异步非阻塞 I/O（ asynchronous IO ）"></a>(5) 异步非阻塞 I/O（ asynchronous IO ）</h1><blockquote><p> 相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://time.geekbang.org/column/article/100861" target="_blank" rel="noopener">答疑课堂：深入了解NIO的优化实现原理</a><br>[2] <a href="https://www.jianshu.com/p/486b0965c296" target="_blank" rel="noopener">聊聊Linux 五种IO模型</a><br>[3] <a href="https://juejin.im/post/5c725dbe51882575e37ef9ed" target="_blank" rel="noopener">linux五种IO模型</a><br>[4] 《Unix网络编程》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络通信中，最底层的就是内核中的网络 I/O 模型了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 随着技术的发展，操作系统内核的网络模型衍生出了五种 I/O 模型，《UNIX 网络编程》一书将这五种 I/O 模型分为 &lt;code&gt;阻塞式 I/O&lt;/code&gt;、&lt;code&gt;非阻塞式 I/O&lt;/code&gt;、&lt;code&gt;I/O 复用&lt;/code&gt;、&lt;code&gt;信号驱动式 I/O&lt;/code&gt; 和 &lt;code&gt;异步 I/O&lt;/code&gt;。每一种 I/O 模型的出现，都是基于前一种 I/O 模型的优化升级。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="io" scheme="http://weikeqin.com/categories/io/"/>
    
    
      <category term="io" scheme="http://weikeqin.com/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>java jmh 使用</title>
    <link href="http://weikeqin.com/2020/06/14/java-jmh-notes/"/>
    <id>http://weikeqin.com/2020/06/14/java-jmh-notes/</id>
    <published>2020-06-14T08:52:52.000Z</published>
    <updated>2020-06-14T14:26:12.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 代码工具：jmh  JMH是一个Java工具，用于构建、运行和分析nano/micro/mili/macro基准，这些基准是用Java和其他针对JVM的语言编写的。<br> Code Tools: jmh  JMH is a Java harness for building, running, and analysing nano/micro/milli/macro benchmarks written in Java and other languages targetting the JVM.</p></blockquote><h1 id="JMH解决了什么问题"><a href="#JMH解决了什么问题" class="headerlink" title="JMH解决了什么问题"></a>JMH解决了什么问题</h1><h1 id="JMH怎么用"><a href="#JMH怎么用" class="headerlink" title="JMH怎么用"></a>JMH怎么用</h1><ol><li>添加对应jar包</li><li>根据实际情况配置参数</li><li>编写代码运行</li></ol><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>@BenchmarkMode<br>用来配置 Mode 选项，可用于类或者方法上，这个注解的 value 是一个数组，可以把几种 Mode 集合在一起执行，如：@BenchmarkMode({Mode.SampleTime, Mode.AverageTime})，还可以设置为 Mode.All，即全部执行一遍。</p><p>Throughput：整体吞吐量，每秒执行了多少次调用，单位为 ops/time<br>AverageTime：用的平均时间，每次操作的平均时间，单位为 time/op<br>SampleTime：随机取样，最后输出取样结果的分布<br>SingleShotTime：只运行一次，往往同时把 Warmup 次数设为 0，用于测试冷启动时的性能<br>All：上面的所有模式都执行一次<br>@State<br>通过 State 可以指定一个对象的作用范围，JMH 根据 scope 来进行实例化和共享操作。@State 可以被继承使用，如果父类定义了该注解，子类则无需定义。由于 JMH 允许多线程同时执行测试，不同的选项含义如下：</p><p>Scope.Benchmark：所有测试线程共享一个实例，测试有状态实例在多线程共享下的性能<br>Scope.Group：同一个线程在同一个 group 里共享实例<br>Scope.Thread：默认的 State，每个测试线程分配一个实例<br>@OutputTimeUnit<br>为统计结果的时间单位，可用于类或者方法注解</p><p>@Warmup<br>预热所需要配置的一些基本测试参数，可用于类或者方法上。一般前几次进行程序测试的时候都会比较慢，所以要让程序进行几轮预热，保证测试的准确性。参数如下所示：</p><p>iterations：预热的次数<br>time：每次预热的时间<br>timeUnit：时间的单位，默认秒<br>batchSize：批处理大小，每次操作调用几次方法<br>为什么需要预热？</p><p>因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译为机器码，从而提高执行速度，所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p><p>@Measurement<br>实际调用方法所需要配置的一些基本测试参数，可用于类或者方法上，参数和 @Warmup 相同。</p><p>@Threads<br>每个进程中的测试线程，可用于类或者方法上。</p><p>@Fork<br>进行 fork 的次数，可用于类或者方法上。如果 fork 数是 2 的话，则 JMH 会 fork 出两个进程来进行测试。</p><p>@Param<br>指定某项参数的多种情况，特别适合用来测试一个函数在不同的参数输入的情况下的性能，只能作用在字段上，使用该注解必须定义 @State 注解。</p><h2 id="编写代码运行"><a href="#编写代码运行" class="headerlink" title="编写代码运行"></a>编写代码运行</h2><blockquote><p> 建议 代码里不要打日志</p></blockquote><h3 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.wkq.java.string.StringInternTest;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.results.format.ResultFormatType;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     JMH使用样例</span></span><br><span class="line"><span class="comment"> *         http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weikeqin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-14 17:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmtTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger log = LoggerFactory.getLogger(StringInternTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"hello JMH"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"开始执行。"</span>);</span><br><span class="line"></span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(JmtTest.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .result(<span class="string">"jmh_result.json"</span>)</span><br><span class="line">                .resultFormat(ResultFormatType.JSON)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"执行完成。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by org.openjdk.jmh.util.Utils (file:/Users/weikeqin1/.m2/repository/org/openjdk/jmh/jmh-core/1.23/jmh-core-1.23.jar) to field java.io.PrintStream.charOut</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of org.openjdk.jmh.util.Utils</span><br><span class="line">WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br><span class="line"># JMH version: 1.23</span><br><span class="line"># VM version: JDK 14.0.1, Java HotSpot(TM) 64-Bit Server VM, 14.0.1+7</span><br><span class="line"># VM invoker: /Library/Java/JavaVirtualMachines/jdk-14.0.1.jdk/Contents/Home/bin/java</span><br><span class="line"># VM options: -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=57492:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: cn.wkq.java.jmh.JmtTest.print</span><br><span class="line"></span><br><span class="line"># Run progress: 0.00% complete, ETA 00:01:40</span><br><span class="line"># Fork: 1 of 1</span><br><span class="line"># Warmup Iteration   1: 660097134.157 ops/s</span><br><span class="line"># Warmup Iteration   2: 650765740.996 ops/s</span><br><span class="line"># Warmup Iteration   3: 661961002.718 ops/s</span><br><span class="line"># Warmup Iteration   4: 672329475.200 ops/s</span><br><span class="line"># Warmup Iteration   5: 611127628.164 ops/s</span><br><span class="line">Iteration   1: 615120987.535 ops/s</span><br><span class="line">Iteration   2: 645989044.177 ops/s</span><br><span class="line">Iteration   3: 642876939.314 ops/s</span><br><span class="line">Iteration   4: 640265656.368 ops/s</span><br><span class="line">Iteration   5: 673185386.638 ops/s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result &quot;cn.wkq.java.jmh.JmtTest.print&quot;:</span><br><span class="line">  643487602.806 ±(99.9%) 79467866.034 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (615120987.535, 643487602.806, 673185386.638), stdev = 20637552.448</span><br><span class="line">  CI (99.9%): [564019736.772, 722955468.841] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:01:42</span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">Benchmark       Mode  Cnt          Score          Error  Units</span><br><span class="line">JmtTest.print  thrpt    5  643487602.806 ± 79467866.034  ops/s</span><br><span class="line"></span><br><span class="line">Benchmark result is saved to jmh_result.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"jmhVersion"</span> : <span class="string">"1.23"</span>,</span><br><span class="line">        <span class="attr">"benchmark"</span> : <span class="string">"cn.wkq.java.jmh.JmtTest.print"</span>,</span><br><span class="line">        <span class="attr">"mode"</span> : <span class="string">"thrpt"</span>,</span><br><span class="line">        <span class="attr">"threads"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"forks"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"jvm"</span> : <span class="string">"/Library/Java/JavaVirtualMachines/jdk-14.0.1.jdk/Contents/Home/bin/java"</span>,</span><br><span class="line">        <span class="attr">"jvmArgs"</span> : [</span><br><span class="line">            <span class="string">"-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=57492:/Applications/IntelliJ IDEA.app/Contents/bin"</span>,</span><br><span class="line">            <span class="string">"-Dfile.encoding=UTF-8"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"jdkVersion"</span> : <span class="string">"14.0.1"</span>,</span><br><span class="line">        <span class="attr">"vmName"</span> : <span class="string">"Java HotSpot(TM) 64-Bit Server VM"</span>,</span><br><span class="line">        <span class="attr">"vmVersion"</span> : <span class="string">"14.0.1+7"</span>,</span><br><span class="line">        <span class="attr">"warmupIterations"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"warmupTime"</span> : <span class="string">"10 s"</span>,</span><br><span class="line">        <span class="attr">"warmupBatchSize"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"measurementIterations"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"measurementTime"</span> : <span class="string">"10 s"</span>,</span><br><span class="line">        <span class="attr">"measurementBatchSize"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"primaryMetric"</span> : &#123;</span><br><span class="line">            <span class="attr">"score"</span> : <span class="number">6.434876028063821E8</span>,</span><br><span class="line">            <span class="attr">"scoreError"</span> : <span class="number">7.946786603420861E7</span>,</span><br><span class="line">            <span class="attr">"scoreConfidence"</span> : [</span><br><span class="line">                <span class="number">5.640197367721734E8</span>,</span><br><span class="line">                <span class="number">7.229554688405907E8</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"scorePercentiles"</span> : &#123;</span><br><span class="line">                <span class="attr">"0.0"</span> : <span class="number">6.151209875347286E8</span>,</span><br><span class="line">                <span class="attr">"50.0"</span> : <span class="number">6.428769393141737E8</span>,</span><br><span class="line">                <span class="attr">"90.0"</span> : <span class="number">6.731853866384177E8</span>,</span><br><span class="line">                <span class="attr">"95.0"</span> : <span class="number">6.731853866384177E8</span>,</span><br><span class="line">                <span class="attr">"99.0"</span> : <span class="number">6.731853866384177E8</span>,</span><br><span class="line">                <span class="attr">"99.9"</span> : <span class="number">6.731853866384177E8</span>,</span><br><span class="line">                <span class="attr">"99.99"</span> : <span class="number">6.731853866384177E8</span>,</span><br><span class="line">                <span class="attr">"99.999"</span> : <span class="number">6.731853866384177E8</span>,</span><br><span class="line">                <span class="attr">"99.9999"</span> : <span class="number">6.731853866384177E8</span>,</span><br><span class="line">                <span class="attr">"100.0"</span> : <span class="number">6.731853866384177E8</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"scoreUnit"</span> : <span class="string">"ops/s"</span>,</span><br><span class="line">            <span class="attr">"rawData"</span> : [</span><br><span class="line">                [</span><br><span class="line">                    <span class="number">6.151209875347286E8</span>,</span><br><span class="line">                    <span class="number">6.459890441766258E8</span>,</span><br><span class="line">                    <span class="number">6.428769393141737E8</span>,</span><br><span class="line">                    <span class="number">6.402656563679644E8</span>,</span><br><span class="line">                    <span class="number">6.731853866384177E8</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"secondaryMetrics"</span> : &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.results.format.ResultFormatType;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     JMH使用样例</span></span><br><span class="line"><span class="comment"> *         http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weikeqin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-14 16:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">3</span>, time = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">5</span>, time = <span class="number">5</span>)</span><br><span class="line"><span class="meta">@Threads</span>(<span class="number">4</span>)</span><br><span class="line"><span class="meta">@Fork</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@State</span>(value = Scope.Benchmark)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringInternTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger log = LoggerFactory.getLogger(StringInternTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Param</span>(value = &#123;<span class="string">"10000"</span>, <span class="string">"100000"</span>, <span class="string">"1000000"</span>&#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringTestWithIntern</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> fm1 = Runtime.getRuntime().freeMemory();</span><br><span class="line"></span><br><span class="line">        List&lt;SharedLocation&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String country = <span class="string">"中国"</span>;</span><br><span class="line">            String province = <span class="string">"山西"</span>;</span><br><span class="line">            String city = <span class="string">"运城"</span>;</span><br><span class="line">            SharedLocation sharedLocation = <span class="keyword">new</span> SharedLocation();</span><br><span class="line">            sharedLocation.setCountry(country.intern());</span><br><span class="line">            sharedLocation.setProvince(province.intern());</span><br><span class="line">            sharedLocation.setCity(city.intern());</span><br><span class="line"></span><br><span class="line">            list.add(sharedLocation);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"个数：&#123;&#125;"</span>, list.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> fm2 = Runtime.getRuntime().freeMemory();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"&#123;&#125;  &#123;&#125;    use &#123;&#125; bytes"</span>, fm1, fm2, fm1 - fm2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringTestWithOutIntern</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> fm1 = Runtime.getRuntime().freeMemory();</span><br><span class="line"></span><br><span class="line">        List&lt;SharedLocation&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String country = <span class="string">"中国"</span>;</span><br><span class="line">            String province = <span class="string">"山西"</span>;</span><br><span class="line">            String city = <span class="string">"运城"</span>;</span><br><span class="line">            SharedLocation sharedLocation = <span class="keyword">new</span> SharedLocation();</span><br><span class="line">            sharedLocation.setCountry(country);</span><br><span class="line">            sharedLocation.setProvince(province);</span><br><span class="line">            sharedLocation.setCity(city);</span><br><span class="line"></span><br><span class="line">            list.add(sharedLocation);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"个数：&#123;&#125;"</span>, list.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> fm2 = Runtime.getRuntime().freeMemory();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"&#123;&#125;  &#123;&#125;    use &#123;&#125; bytes"</span>, fm1, fm2, fm1 - fm2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"开始执行。"</span>);</span><br><span class="line"></span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(StringInternTest.class.getSimpleName())</span><br><span class="line">                .result(<span class="string">"result.json"</span>)</span><br><span class="line">                .resultFormat(ResultFormatType.JSON).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RunnerException e) &#123;</span><br><span class="line">            log.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"执行完成。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedLocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 市</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 国家</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(String province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountry</span><span class="params">(String country)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">900761252.400 ±(99.9%) 836615744.826 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result &quot;cn.wkq.java.string.StringInternTest.stringTestWithOutIntern&quot;:</span><br><span class="line">  763138737.923 ±(99.9%) 930573867.253 ns/op [Average]</span><br><span class="line">  (min, avg, max) = (439268202.215, 763138737.923, 1017594855.563), stdev = 241667078.162</span><br><span class="line">  CI (99.9%): [≈ 0, 1693712605.176] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:03:34</span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">Benchmark                                 (count)  Mode  Cnt           Score           Error  Units</span><br><span class="line">StringInternTest.stringTestWithIntern       10000  avgt    5    13128831.111 ±   1999580.768  ns/op</span><br><span class="line">StringInternTest.stringTestWithIntern      100000  avgt    5   157188187.749 ±  99748905.878  ns/op</span><br><span class="line">StringInternTest.stringTestWithIntern     1000000  avgt    5  1813072765.600 ± 619163864.504  ns/op</span><br><span class="line">StringInternTest.stringTestWithOutIntern    10000  avgt    5     1511080.000 ±    872905.808  ns/op</span><br><span class="line">StringInternTest.stringTestWithOutIntern   100000  avgt    5     8238751.953 ±   1401387.637  ns/op</span><br><span class="line">StringInternTest.stringTestWithOutIntern  1000000  avgt    5   763138737.923 ± 930573867.253  ns/op</span><br><span class="line"></span><br><span class="line">Benchmark result is saved to result.json</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://mp.weixin.qq.com/s/_LHV1PNbbCV9_d9aWzKOyg" target="_blank" rel="noopener">性能调优必备利器之JMH</a><br>[2] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/" target="_blank" rel="noopener">openjdk/jmh/samples/</a><br>[3] <a href="https://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">code-tools/jmh</a><br>[4] <a href="https://javadoc.io/doc/org.openjdk.jmh/jmh-core/latest/index.html" target="_blank" rel="noopener">jmh-core api</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 代码工具：jmh  JMH是一个Java工具，用于构建、运行和分析nano/micro/mili/macro基准，这些基准是用Java和其他针对JVM的语言编写的。&lt;br&gt; Code Tools: jmh  JMH is a Java harness for building, running, and analysing nano/micro/milli/macro benchmarks written in Java and other languages targetting the JVM.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;JMH解决了什么问题&quot;&gt;&lt;a href=&quot;#JMH解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;JMH解决了什么问题&quot;&gt;&lt;/a&gt;JMH解决了什么问题&lt;/h1&gt;&lt;h1 id=&quot;JMH怎么用&quot;&gt;&lt;a href=&quot;#JMH怎么用&quot; class=&quot;headerlink&quot; title=&quot;JMH怎么用&quot;&gt;&lt;/a&gt;JMH怎么用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;添加对应jar包&lt;/li&gt;
&lt;li&gt;根据实际情况配置参数&lt;/li&gt;
&lt;li&gt;编写代码运行&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;添加依赖&quot;&gt;&lt;a href=&quot;#添加依赖&quot; class=&quot;headerlink&quot; title=&quot;添加依赖&quot;&gt;&lt;/a&gt;添加依赖&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.openjdk.jmh&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jmh-core&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.23&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.openjdk.jmh&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jmh-generator-annprocess&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.23&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="http://weikeqin.com/categories/java/"/>
    
    
      <category term="java" scheme="http://weikeqin.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-performance-tuning</title>
    <link href="http://weikeqin.com/2020/06/14/java-performance-tuning/"/>
    <id>http://weikeqin.com/2020/06/14/java-performance-tuning/</id>
    <published>2020-06-14T07:04:39.000Z</published>
    <updated>2020-06-14T14:25:51.889Z</updated>
    
    <content type="html"><![CDATA[<p>  Java 性能调优不像是学一门编程语言，无法通过直线式的思维来掌握和应用，它对于工程师的技术广度和深度都有着较高的要求。<br>  互联网时代，一个简单的系统就囊括了应用程序、数据库、容器、操作系统、网络等技术，线上一旦出现性能问题，就可能要你协调多方面组件去进行优化，这就是技术广度；而很多性能问题呢，又隐藏得很深，可能因为一个小小的代码，也可能因为线程池的类型选择错误…可归根结底考验的还是我们对这项技术的了解程度，这就是技术深度。</p><p>  我们调优的对象不是单一的应用服务，而是错综复杂的系统。应用服务的性能可能与操作系统、网络、数据库等组件相关，所以我们需要储备计算机组成原理、操作系统、网络协议以及数据库等基础知识。具体的性能问题往往还与传输、计算、存储数据等相关，那我们还需要储备数据结构、算法以及数学等基础知识。</p><p>  如果你们公司做的是 12306 网站，不做系统性能优化就上线，试试看会是什么情况。</p><p>  一款线上产品如果没有经过性能测试，那它就好比是一颗定时炸弹，你不知道它什么时候会出现问题，你也不清楚它能承受的极限在哪儿。</p><p>  好的系统性能调优不仅仅可以提高系统的性能，还能为公司节省资源</p><a id="more"></a><p>  有哪些参考因素可以体现系统的性能？上面我们讲到了在项目研发的各个阶段性能调优是如何介入的，其中多次讲到了性能指标，那么性能指标到底有哪些呢？在我们了解性能指标之前，我们先来了解下哪些计算机资源会成为系统的性能瓶颈。CPU：有的应用需要大量计算，他们会长时间、不间断地占用 CPU 资源，导致其他资源无法争夺到 CPU 而响应缓慢，从而带来系统性能问题。例如，代码递归导致的无限循环，正则表达式引起的回溯，JVM 频繁的 FULL GC，以及多线程编程造成的大量上下文切换等，这些都有可能导致 CPU 资源繁忙。内存：Java 程序一般通过 JVM 对内存进行分配管理，主要是用 JVM 中的堆内存来存储 Java 创建的对象。系统堆内存的读写速度非常快，所以基本不存在读写性能瓶颈。但是由于内存成本要比磁盘高，相比磁盘，内存的存储空间又非常有限。所以当内存空间被占满，对象无法回收时，就会导致内存溢出、内存泄露等问题。磁盘 I/O：磁盘相比内存来说，存储空间要大很多，但磁盘 I/O 读写的速度要比内存慢，虽然目前引入的 SSD 固态硬盘已经有所优化，但仍然无法与内存的读写速度相提并论。网络：网络对于系统性能来说，也起着至关重要的作用。如果你购买过云服务，一定经历过，选择网络带宽大小这一环节。带宽过低的话，对于传输数据比较大，或者是并发量比较大的系统，网络就很容易成为性能瓶颈。异常：Java 应用中，抛出异常需要构建异常栈，对异常进行捕获和处理，这个过程非常消耗系统性能。如果在高并发的情况下引发异常，持续地进行异常处理，那么系统的性能就会明显地受到影响。数据库：大部分系统都会用到数据库，而数据库的操作往往是涉及到磁盘 I/O 的读写。大量的数据库读写操作，会导致磁盘 I/O 性能瓶颈，进而导致数据库操作的延迟性。对于有大量数据库读写操作的系统来说，数据库的性能优化是整个系统的核心。锁竞争：在并发编程中，我们经常会需要多个线程，共享读写操作同一个资源，这个时候为了保持数据的原子性（即保证这个共享资源在一个线程写的时候，不被另一个线程修改），我们就会用到锁。锁的使用可能会带来上下文切换，从而给系统带来性能开销。JDK1.6 之后，Java 为了降低锁竞争带来的上下文切换，对 JVM 内部锁已经做了多次优化，例如，新增了偏向锁、自旋锁、轻量级锁、锁粗化、锁消除等。而如何合理地使用锁资源</p><p>  数据库响应时间：数据库操作所消耗的时间，往往是整个请求链中最耗时的；<br>  服务端响应时间：服务端包括 Nginx 分发的请求所消耗的时间以及服务端程序执行所消耗的时间；<br>  网络响应时间：这是网络传输时，网络硬件需要对传输的请求进行解析等操作所消耗的时间；<br>  客户端响应时间：对于普通的 Web、App 客户端来说，消耗时间是可以忽略不计的，但如果你的客户端嵌入了大量的逻辑处理，消耗的时间就有可能变长，从而成为系统的瓶颈。</p><p>  网络吞吐量不仅仅跟带宽有关系，还跟 CPU 的处理能力、网卡、防火墙、外部接口以及 I/O 等紧密关联。</p><p>  当系统压力上升时，你可以观察，系统响应时间的上升曲线是否平缓。这项指标能直观地反馈给你，系统所能承受的负载压力极限。</p><p>  QPS特指的一次查询请求，TPS是指每次处理事务请求，TPS包括了QPS，例如一个事务处理可能包括多个查询请求。</p><p>  当我们做性能测试时，我们的系统会运行得越来越快，后面的访问速度要比我们第一次访问的速度快上几倍。这是怎么回事呢？<br>  在 Java 编程语言和环境中，.java 文件编译成为 .class 文件后，机器还是无法直接运行 .class 文件中的字节码，需要通过解释器将字节码转换成本地机器码才能运行。<br>  为了节约内存和执行效率，代码最初被执行时，解释器会率先解释执行这段代码。<br>  随着代码被执行的次数增多，当虚拟机发现某个方法或代码块运行得特别频繁时，就会把这些代码认定为热点代码（Hot Spot Code）。<br>  为了提高热点代码的执行效率，在运行时，虚拟机将会通过即时编译器（JIT compiler，just-in-time compiler）把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后存储在内存中，之后每次运行代码时，直接从内存中获取即可。</p><p>  在完成性能测试之后，需要输出一份性能测试报告，帮我们分析系统性能测试的情况。<br>  其中测试结果需要包含测试接口的平均、最大和最小吞吐量，响应时间，服务器的 CPU、内存、I/O、网络 IO 使用率，JVM 的 GC 频率等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedLocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String city;</span><br><span class="line">  <span class="keyword">private</span> String region;</span><br><span class="line">  <span class="keyword">private</span> String countryCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SharedLocation sharedLocation;</span><br><span class="line">  <span class="keyword">double</span> longitude;</span><br><span class="line">  <span class="keyword">double</span> latitude;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SharedLocation sharedLocation = new SharedLocation();</span><br><span class="line"></span><br><span class="line">sharedLocation.setCity(messageInfo.getCity().intern());    </span><br><span class="line">sharedLocation.setCountryCode(messageInfo.getRegion().intern());</span><br><span class="line">sharedLocation.setRegion(messageInfo.getCountryCode().intern());</span><br><span class="line"></span><br><span class="line">Location location = new Location();</span><br><span class="line">location.set(sharedLocation);</span><br><span class="line">location.set(messageInfo.getLongitude());</span><br><span class="line">location.set(messageInfo.getLatitude());</span><br></pre></td></tr></table></figure><p>严格来说，是静态常量池和运行时常量池，静态常量池是存放字符串字面量、符号引用以及类和方法的信息，而运行时常量池存放的是运行时一些直接引用。</p><p>运行时常量池是在类加载完成之后，将静态常量池中的符号引用值转存到运行时常量池中，类在解析之后，将符号引用替换成直接引用。</p><p>这两个常量池在JDK1.7版本之后，就移到堆内存中了，这里指的是物理空间，而逻辑上还是属于方法区（方法区是逻辑分区）。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式引擎<br>  DFA 自动机（Deterministic Final Automaton 确定有限状态自动机）<br>  NFA 自动机（Non deterministic Finite Automaton 非确定有限状态自动机）</p><p>构造 DFA 自动机的代价远大于 NFA 自动机，但 DFA 自动机的执行效率高于 NFA 自动机</p><p>  贪婪模式（Greedy）  顾名思义，就是在数量匹配中，如果单独使用 +、 ? 、* 或{min,max} 等量词，正则表达式会匹配尽可能多的内容。<br>    text=“abbc” regex=“ab{1,3}c”<br>  懒惰模式（Reluctant）在该模式下，正则表达式会尽可能少地重复匹配字符。如果匹配成功，它会继续匹配剩余的字符串。<br>    text=“abbc” regex=“ab{1,3}?c”<br>  独占模式（Possessive）同贪婪模式一样，独占模式一样会最大限度地匹配更多内容；不同的是，在独占模式下，匹配失败就会结束匹配，不会发生回溯问题。<br>    text=“abbc” regex=“ab{1,3}+bc”</p><blockquote><p> 在很多情况下使用懒惰模式和独占模式可以减少回溯的发生。</p></blockquote><blockquote><ol><li>少用贪婪模式，多用独占模式</li><li>减少分支选择   分支选择类型“(X|Y|Z)”的正则表达式会降低性能</li><li>减少捕获嵌套     一般一个 () 就是一个捕获组，捕获组可以进行嵌套。</li></ol></blockquote><p>  for(:)循环[这里指的不是for(;;)]是一个语法糖，这里会被解释为迭代器，在使用迭代器遍历时，ArrayList内部创建了一个内部迭代器iterator，在使用next()方法来取下一个元素时，会使用ArrayList里保存的一个用来记录List修改次数的变量modCount，与iterator保存了一个expectedModCount来表示期望的修改次数进行比较，如果不相等则会抛出异常；</p><p>  而在在foreach循环中调用list中的remove()方法，会走到fastRemove()方法，该方法不是iterator中的方法，而是ArrayList中的方法，在该方法只做了modCount++，而没有同步到expectedModCount。</p><p>  当再次遍历时，会先调用内部类iteator中的hasNext(),再调用next(),在调用next()方法时，会对modCount和expectedModCount进行比较，此时两者不一致，就抛出了ConcurrentModificationException异常。</p><p>  所以关键是用ArrayList的remove还是iterator中的remove。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  Java 性能调优不像是学一门编程语言，无法通过直线式的思维来掌握和应用，它对于工程师的技术广度和深度都有着较高的要求。&lt;br&gt;  互联网时代，一个简单的系统就囊括了应用程序、数据库、容器、操作系统、网络等技术，线上一旦出现性能问题，就可能要你协调多方面组件去进行优化，这就是技术广度；而很多性能问题呢，又隐藏得很深，可能因为一个小小的代码，也可能因为线程池的类型选择错误…可归根结底考验的还是我们对这项技术的了解程度，这就是技术深度。&lt;/p&gt;
&lt;p&gt;  我们调优的对象不是单一的应用服务，而是错综复杂的系统。应用服务的性能可能与操作系统、网络、数据库等组件相关，所以我们需要储备计算机组成原理、操作系统、网络协议以及数据库等基础知识。具体的性能问题往往还与传输、计算、存储数据等相关，那我们还需要储备数据结构、算法以及数学等基础知识。&lt;/p&gt;
&lt;p&gt;  如果你们公司做的是 12306 网站，不做系统性能优化就上线，试试看会是什么情况。&lt;/p&gt;
&lt;p&gt;  一款线上产品如果没有经过性能测试，那它就好比是一颗定时炸弹，你不知道它什么时候会出现问题，你也不清楚它能承受的极限在哪儿。&lt;/p&gt;
&lt;p&gt;  好的系统性能调优不仅仅可以提高系统的性能，还能为公司节省资源&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://weikeqin.com/categories/java/"/>
    
    
      <category term="java" scheme="http://weikeqin.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>并发模型</title>
    <link href="http://weikeqin.com/2020/06/13/concurrent-model/"/>
    <id>http://weikeqin.com/2020/06/13/concurrent-model/</id>
    <published>2020-06-13T15:17:59.000Z</published>
    <updated>2020-06-14T03:54:36.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Actor"><a href="#1-Actor" class="headerlink" title="(1) Actor"></a>(1) Actor</h1><blockquote><p> Actor模型：面向对象原生的并发模型</p></blockquote><blockquote><p> Actor模型是高性能网络中处理并行任务的一种方法，解决并发问题的利器</p></blockquote><blockquote><p> Actor模型本质上是一种计算模型，基本的计算单元称为 Actor，在 Actor 模型里，一切都是 Actor，所有的计算都是在 Actor 中执行的，并且 Actor 之间是完全隔离的，不会共享任何变量。  </p></blockquote><blockquote><p> Actor模型解决了 传统编程假设与现代多线程、多CPU架构的现实之间的不匹配问题。</p><ol><li>消息传递的使用避免了锁和阻塞。  </li><li>Actor能够优化地处理错误情况。 </li></ol></blockquote><blockquote><p> Java 语言本身并不支持 Actor 模型，所以如果你想在 Java 语言里使用 Actor 模型，就需要借助第三方类库，目前能完备地支持 Actor 模型而且比较成熟的类库就是 Akka。</p></blockquote><a id="more"></a><h1 id="2-STM"><a href="#2-STM" class="headerlink" title="(2) STM"></a>(2) STM</h1><p>  软件事务内存（Software Transactional Memory，简称 STM）</p><blockquote><p> 传统的数据库事务，支持 4 个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），也就是大家常说的 ACID<br> STM 由于不涉及到持久化，所以只支持 ACI。 </p></blockquote><p>  <a href="https://github.com/pveentjer/Multiverse" target="_blank" rel="noopener">Multiverse</a><br>  <a href="http://www.codecommit.com/blog/scala/software-transactional-memory-in-scala" target="_blank" rel="noopener">software-transactional-memory-in-scala</a><br>  <a href="https://github.com/epam-mooc/stm-java" target="_blank" rel="noopener">stm-java</a></p><p><br></p><h1 id="3-协程"><a href="#3-协程" class="headerlink" title="(3) 协程"></a>(3) 协程</h1><blockquote><p> 我们可以把协程简单地理解为一种轻量级的线程。从操作系统的角度来看，线程是在内核态中调度的，而协程是在用户态调度的，所以相对于线程来说，协程切换的成本更低。协程虽然也有自己的栈，但是相比线程栈要小得多，典型的线程栈大小差不多有 1M，而协程栈的大小往往只有几 K 或者几十 K。所以，无论是从时间维度还是空间维度来看，协程都比线程轻量得多。</p></blockquote><blockquote><p> 支持协程的语言还是挺多的，例如 Golang、Python、Lua、Kotlin 等都支持协程。</p></blockquote><h2 id="3-1-golang中的协程"><a href="#3-1-golang中的协程" class="headerlink" title="(3.1) golang中的协程"></a>(3.1) golang中的协程</h2><blockquote><p> 在 Golang 中创建协程非常简单，在下面的示例代码中，要让 hello() 方法在一个新的协程中执行，只需要go hello(“World”) 这一行代码就搞定了。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello "</span> + msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//在新的协程中执行hello方法</span></span><br><span class="line">  <span class="keyword">go</span> hello(<span class="string">"World"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Run in main"</span>)</span><br><span class="line">    <span class="comment">//等待100毫秒让协程执行结束</span></span><br><span class="line">  time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="4-CSP模型"><a href="#4-CSP模型" class="headerlink" title="(4) CSP模型"></a>(4) CSP模型</h1><p>  CSP（Communicating Sequential Processes）</p><blockquote><p> 打印从 1 累加到 100 亿的结果，如果使用单个协程来计算，大概需要 4 秒多的时间。单个协程，只能用到 CPU 中的一个核，为了提高计算性能，我们可以用多个协程来并行计算，这样就能发挥多核的优势了。<br> 用了 4 个子协程来并行执行，这 4 个子协程分别计算[1, 25 亿]、(25 亿, 50 亿]、(50 亿, 75 亿]、(75 亿, 100 亿]，最后再在主协程中汇总 4 个子协程的计算结果。主协程要汇总 4 个子协程的计算结果，势必要和 4 个子协程之间通信，Golang 中协程之间通信推荐的是使用 channel，channel 你可以形象地理解为现实世界里的管道。</p></blockquote><pre><code class="go"><span class="keyword">import</span> (  <span class="string">"fmt"</span>  <span class="string">"time"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {    <span class="comment">// 变量声明</span>  <span class="keyword">var</span> result, i <span class="keyword">uint64</span>    <span class="comment">// 单个协程执行累加操作</span>  start := time.Now()  <span class="keyword">for</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000000000</span>; i++ {    result += i  }  <span class="comment">// 统计计算耗时</span>  elapsed := time.Since(start)  fmt.Printf(<span class="string">"执行消耗的时间为:"</span>, elapsed)  fmt.Println(<span class="string">", result:"</span>, result)    <span class="comment">// 4个协程共同执行累加操作</span>  start = time.Now()  ch1 := calc(<span class="number">1</span>, <span class="number">2500000000</span>)  ch2 := calc(<span class="number">2500000001</span>, <span class="number">5000000000</span>)  ch3 := calc(<span class="number">5000000001</span>, <span class="number">7500000000</span>)  ch4 := calc(<span class="number">7500000001</span>, <span class="number">10000000000</span>)    <span class="comment">// 汇总4个协程的累加结果</span>  result = &lt;-ch1 + &lt;-ch2 + &lt;-ch3 + &lt;-ch4  <span class="comment">// 统计计算耗时</span>  elapsed = time.Since(start)  fmt.Printf(<span class="string">"执行消耗的时间为:"</span>, elapsed)  fmt.Println(<span class="string">", result:"</span>, result)}<span class="comment">// 在协程中异步执行累加操作，累加结果通过channel传递</span><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(from <span class="keyword">uint64</span>, to <span class="keyword">uint64</span>)</span> &lt;-<span class="title">chan</span> <span class="title">uint64</span></span> {    <span class="comment">// channel用于协程间的通信</span>  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>)    <span class="comment">// 在协程中执行累加操作</span>  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {    result := from    <span class="keyword">for</span> i := from + <span class="number">1</span>; i &lt;= to; i++ {      result += i    }        <span class="comment">// 将结果写入channel</span>    ch &lt;- result  }()    <span class="comment">// 返回结果是用于通信的channel</span>  <span class="keyword">return</span> ch}</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://time.geekbang.org/column/article/98903" target="_blank" rel="noopener">42 | Actor模型：面向对象原生的并发模型</a><br>[2] <a href="https://time.geekbang.org/column/article/99251" target="_blank" rel="noopener">43 | 软件事务内存：借鉴数据库的并发经验</a><br>[3] <a href="https://time.geekbang.org/column/article/99787" target="_blank" rel="noopener">44 | 协程：更轻量级的线程</a><br>[4] <a href="https://time.geekbang.org/column/article/100098" target="_blank" rel="noopener">45 | CSP模型：Golang的主力队员</a><br>[5] <a href="https://doc.akka.io/docs/akka/2.2/AkkaJava.pdf" target="_blank" rel="noopener">doc.akka.io/docs/akka/2.2/AkkaJava.pdf</a><br>[6] <a href="https://developer.lightbend.com/guides/akka-quickstart-java/" target="_blank" rel="noopener">guides/akka-quickstart-java</a><br>[7] <a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-quickstart-java" target="_blank" rel="noopener">akka-quickstart-java</a><br>[8] <a href="https://doc.akka.io/docs/akka/current/index.html" target="_blank" rel="noopener">doc.akka.io/docs/akka/current</a><br>[9] <a href="https://github.com/guobinhit/akka-guide" target="_blank" rel="noopener">akka-guide</a><br>[10] <a href="https://github.com/epam-mooc/stm-java" target="_blank" rel="noopener">stm-java</a><br>[11] <a href="http://www.codecommit.com/blog/scala/software-transactional-memory-in-scala" target="_blank" rel="noopener">software-transactional-memory-in-scala</a><br>[12] <a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/" target="_blank" rel="noopener">notes-on-structured-concurrency-or-go-statement-considered-harmful</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Actor&quot;&gt;&lt;a href=&quot;#1-Actor&quot; class=&quot;headerlink&quot; title=&quot;(1) Actor&quot;&gt;&lt;/a&gt;(1) Actor&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; Actor模型：面向对象原生的并发模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Actor模型是高性能网络中处理并行任务的一种方法，解决并发问题的利器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Actor模型本质上是一种计算模型，基本的计算单元称为 Actor，在 Actor 模型里，一切都是 Actor，所有的计算都是在 Actor 中执行的，并且 Actor 之间是完全隔离的，不会共享任何变量。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Actor模型解决了 传统编程假设与现代多线程、多CPU架构的现实之间的不匹配问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息传递的使用避免了锁和阻塞。  &lt;/li&gt;
&lt;li&gt;Actor能够优化地处理错误情况。 &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Java 语言本身并不支持 Actor 模型，所以如果你想在 Java 语言里使用 Actor 模型，就需要借助第三方类库，目前能完备地支持 Actor 模型而且比较成熟的类库就是 Akka。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="concurrent" scheme="http://weikeqin.com/categories/concurrent/"/>
    
    
      <category term="concurrent" scheme="http://weikeqin.com/tags/concurrent/"/>
    
      <category term="model" scheme="http://weikeqin.com/tags/model/"/>
    
  </entry>
  
  <entry>
    <title>akka笔记</title>
    <link href="http://weikeqin.com/2020/06/13/akka-notes/"/>
    <id>http://weikeqin.com/2020/06/13/akka-notes/</id>
    <published>2020-06-13T14:26:44.000Z</published>
    <updated>2020-06-14T03:57:03.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> Akka is a toolkit and runtime for building highly concurrent, distributed, and fault-tolerant event-driven applications on the JVM. Akka can be used with both Java and Scala. This guide introduces Akka by describing the Java version of the Hello World example. If you prefer to use Akka with Scala, switch to the Akka Quickstart with Scala guide.</p></blockquote><blockquote><p> Actors are the unit of execution in Akka. The Actor model is an abstraction that makes it easier to write correct concurrent, parallel and distributed systems. The Hello World example illustrates Akka basics. Within 30 minutes, you should be able to download and run the example and use this guide to understand how the example is constructed. This will get your feet wet, and hopefully inspire you to dive deeper into the wonderful sea of Akka!</p></blockquote><h1 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h1><blockquote><p> Akka是Actor模型的一种实现<br> Actor模型解决了 传统编程假设与现代多线程、多CPU架构的现实之间的不匹配问题。</p><ol><li>消息传递的使用避免了锁和阻塞。  </li><li>Actor能够优化地处理错误情况。 </li></ol></blockquote><blockquote><p> Usage of message passing avoids locking and blocking.<br> Actors handle error situations gracefully</p></blockquote><p><strong> OOP在构建苛刻需求的分布式系统会遇到的问题 </strong></p><blockquote><ol><li>并发情况下封装导致效率问题和死锁问题。</li><li>并发时共享内存失效(CPU缓存失效导致)导致效率低的问题。</li><li>调用栈导致的后台线程在异常时的通信问题以及后续问题。</li></ol></blockquote><blockquote><ol><li>The challenge of encapsulation</li><li>The illusion of shared memory on modern computer architectures</li><li>The illusion of a call stack</li></ol></blockquote><a id="more"></a><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote><p> After trying this example the comprehensive Getting Started Guide is a good next step to continue learning more about Akka.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">bogon:akka-quickstart-java weikeqin1$</span><br><span class="line">bogon:akka-quickstart-java weikeqin1$ mvn compile exec:exec</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-compiler-plugin/3.5.1/maven-compiler-plugin-3.5.1.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-compiler-plugin/3.5.1/maven-compiler-plugin-3.5.1.pom (10 kB at 15 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-compiler-plugin/3.5.1/maven-compiler-plugin-3.5.1.jar</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-compiler-plugin/3.5.1/maven-compiler-plugin-3.5.1.jar (50 kB at 138 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/mojo/exec-maven-plugin/1.6.0/exec-maven-plugin-1.6.0.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/mojo/exec-maven-plugin/1.6.0/exec-maven-plugin-1.6.0.pom (13 kB at 65 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/mojo/exec-maven-plugin/1.6.0/exec-maven-plugin-1.6.0.jar</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/mojo/exec-maven-plugin/1.6.0/exec-maven-plugin-1.6.0.jar (58 kB at 179 kB/s)</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ------------------------&lt; hello-akka-java:app &gt;-------------------------</span><br><span class="line">[INFO] Building app 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-actor-typed_2.13/2.6.6/akka-actor-typed_2.13-2.6.6.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-actor-typed_2.13/2.6.6/akka-actor-typed_2.13-2.6.6.pom (2.6 kB at 11 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-slf4j_2.13/2.6.6/akka-slf4j_2.13-2.6.6.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-slf4j_2.13/2.6.6/akka-slf4j_2.13-2.6.6.pom (2.9 kB at 7.9 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-actor-testkit-typed_2.13/2.6.6/akka-actor-testkit-typed_2.13-2.6.6.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-actor-testkit-typed_2.13/2.6.6/akka-actor-testkit-typed_2.13-2.6.6.pom (3.6 kB at 12 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-testkit_2.13/2.6.6/akka-testkit_2.13-2.6.6.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-testkit_2.13/2.6.6/akka-testkit_2.13-2.6.6.pom (3.5 kB at 10 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-actor-typed_2.13/2.6.6/akka-actor-typed_2.13-2.6.6.jar</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-testkit_2.13/2.6.6/akka-testkit_2.13-2.6.6.jar</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-actor-testkit-typed_2.13/2.6.6/akka-actor-testkit-typed_2.13-2.6.6.jar</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-slf4j_2.13/2.6.6/akka-slf4j_2.13-2.6.6.jar</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-slf4j_2.13/2.6.6/akka-slf4j_2.13-2.6.6.jar (17 kB at 38 kB/s)</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-testkit_2.13/2.6.6/akka-testkit_2.13-2.6.6.jar (261 kB at 328 kB/s)</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-actor-testkit-typed_2.13/2.6.6/akka-actor-testkit-typed_2.13-2.6.6.jar (315 kB at 382 kB/s)</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/com/typesafe/akka/akka-actor-typed_2.13/2.6.6/akka-actor-typed_2.13-2.6.6.jar (1.2 MB at 1.1 MB/s)</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ app ---</span><br><span class="line">[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!</span><br><span class="line">[INFO] Copying 1 resource</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.5.1:compile (default-compile) @ app ---</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-api/2.7/plexus-compiler-api-2.7.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-api/2.7/plexus-compiler-api-2.7.pom (891 B at 3.2 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler/2.7/plexus-compiler-2.7.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler/2.7/plexus-compiler-2.7.pom (4.9 kB at 34 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-manager/2.7/plexus-compiler-manager-2.7.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-manager/2.7/plexus-compiler-manager-2.7.pom (711 B at 3.0 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-javac/2.7/plexus-compiler-javac-2.7.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-javac/2.7/plexus-compiler-javac-2.7.pom (792 B at 5.3 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compilers/2.7/plexus-compilers-2.7.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compilers/2.7/plexus-compilers-2.7.pom (1.4 kB at 3.1 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-api/2.7/plexus-compiler-api-2.7.jar</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-manager/2.7/plexus-compiler-manager-2.7.jar</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-javac/2.7/plexus-compiler-javac-2.7.jar</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-manager/2.7/plexus-compiler-manager-2.7.jar (4.7 kB at 30 kB/s)</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-javac/2.7/plexus-compiler-javac-2.7.jar (19 kB at 113 kB/s)</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-compiler-api/2.7/plexus-compiler-api-2.7.jar (26 kB at 90 kB/s)</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 4 source files to /Users/weikeqin1/Downloads/akka-quickstart-java/target/classes</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- exec-maven-plugin:1.6.0:exec (default-cli) @ app ---</span><br><span class="line">SLF4J: A number (1) of logging calls during the initialization phase have been intercepted and are</span><br><span class="line">SLF4J: now being replayed. These are subject to the filtering rules of the underlying logging system.</span><br><span class="line">SLF4J: See also http://www.slf4j.org/codes.html#replay</span><br><span class="line">[2020-06-13 22:44:03,567] [INFO] [akka.event.slf4j.Slf4jLogger] [helloakka-akka.actor.default-dispatcher-3] [] - Slf4jLogger started</span><br><span class="line">&gt;&gt;&gt; Press ENTER to exit &lt;&lt;&lt;</span><br><span class="line">[2020-06-13 22:44:03,660] [INFO] [com.example.Greeter] [helloakka-akka.actor.default-dispatcher-5] [akka://helloakka/user/greeter] - Hello Charles!</span><br><span class="line">[2020-06-13 22:44:03,663] [INFO] [com.example.GreeterBot] [helloakka-akka.actor.default-dispatcher-3] [akka://helloakka/user/Charles] - Greeting 1 for Charles</span><br><span class="line">[2020-06-13 22:44:03,663] [INFO] [com.example.Greeter] [helloakka-akka.actor.default-dispatcher-5] [akka://helloakka/user/greeter] - Hello Charles!</span><br><span class="line">[2020-06-13 22:44:03,663] [INFO] [com.example.GreeterBot] [helloakka-akka.actor.default-dispatcher-3] [akka://helloakka/user/Charles] - Greeting 2 for Charles</span><br><span class="line">[2020-06-13 22:44:03,663] [INFO] [com.example.Greeter] [helloakka-akka.actor.default-dispatcher-5] [akka://helloakka/user/greeter] - Hello Charles!</span><br><span class="line">[2020-06-13 22:44:03,664] [INFO] [com.example.GreeterBot] [helloakka-akka.actor.default-dispatcher-5] [akka://helloakka/user/Charles] - Greeting 3 for Charles</span><br><span class="line"></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  23.459 s</span><br><span class="line">[INFO] Finished at: 2020-06-13T22:44:16+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">bogon:akka-quickstart-java weikeqin1$</span><br><span class="line">bogon:akka-quickstart-java weikeqin1$</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.ActorSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AkkaQuickstart</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//#actor-system</span></span><br><span class="line">    <span class="keyword">final</span> ActorSystem&lt;GreeterMain.SayHello&gt; greeterMain = ActorSystem.create(GreeterMain.create(), <span class="string">"helloakka"</span>);</span><br><span class="line">    <span class="comment">//#actor-system</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//#main-send-messages</span></span><br><span class="line">    greeterMain.tell(<span class="keyword">new</span> GreeterMain.SayHello(<span class="string">"Charles"</span>));</span><br><span class="line">    <span class="comment">//#main-send-messages</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"&gt;&gt;&gt; Press ENTER to exit &lt;&lt;&lt;"</span>);</span><br><span class="line">      System.in.read();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      greeterMain.terminate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.ActorRef;</span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.Behavior;</span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.javadsl.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #greeter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>&lt;<span class="title">Greeter</span>.<span class="title">Greet</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Greet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String whom;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ActorRef&lt;Greeted&gt; replyTo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Greet</span><span class="params">(String whom, ActorRef&lt;Greeted&gt; replyTo)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.whom = whom;</span><br><span class="line">      <span class="keyword">this</span>.replyTo = replyTo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeted</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String whom;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ActorRef&lt;Greet&gt; from;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Greeted</span><span class="params">(String whom, ActorRef&lt;Greet&gt; from)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.whom = whom;</span><br><span class="line">      <span class="keyword">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #greeter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      Greeted greeted = (Greeted) o;</span><br><span class="line">      <span class="keyword">return</span> Objects.equals(whom, greeted.whom) &amp;&amp;</span><br><span class="line">              Objects.equals(from, greeted.from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Objects.hash(whom, from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Greeted&#123;"</span> +</span><br><span class="line">              <span class="string">"whom='"</span> + whom + <span class="string">'\''</span> +</span><br><span class="line">              <span class="string">", from="</span> + from +</span><br><span class="line">              <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// #greeter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Behavior&lt;Greet&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Behaviors.setup(Greeter::<span class="keyword">new</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Greeter</span><span class="params">(ActorContext&lt;Greet&gt; context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Receive&lt;Greet&gt; <span class="title">createReceive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newReceiveBuilder().onMessage(Greet.class, <span class="keyword">this</span>::onGreet).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Behavior&lt;Greet&gt; <span class="title">onGreet</span><span class="params">(Greet command)</span> </span>&#123;</span><br><span class="line">    getContext().getLog().info(<span class="string">"Hello &#123;&#125;!"</span>, command.whom);</span><br><span class="line">    <span class="comment">//#greeter-send-message</span></span><br><span class="line">    command.replyTo.tell(<span class="keyword">new</span> Greeted(command.whom, getContext().getSelf()));</span><br><span class="line">    <span class="comment">//#greeter-send-message</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #greeter</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.Behavior;</span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.javadsl.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreeterBot</span> <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>&lt;<span class="title">Greeter</span>.<span class="title">Greeted</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Behavior&lt;Greeter.Greeted&gt; create(<span class="keyword">int</span> max) &#123;</span><br><span class="line">        <span class="keyword">return</span> Behaviors.setup(context -&gt; <span class="keyword">new</span> GreeterBot(context, max));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> greetingCounter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GreeterBot</span><span class="params">(ActorContext&lt;Greeter.Greeted&gt; context, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Receive&lt;Greeter.Greeted&gt; createReceive() &#123;</span><br><span class="line">        <span class="keyword">return</span> newReceiveBuilder().onMessage(Greeter.Greeted.class, <span class="keyword">this</span>::onGreeted).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Behavior&lt;Greeter.Greeted&gt; onGreeted(Greeter.Greeted message) &#123;</span><br><span class="line">        greetingCounter++;</span><br><span class="line">        getContext().getLog().info(<span class="string">"Greeting &#123;&#125; for &#123;&#125;"</span>, greetingCounter, message.whom);</span><br><span class="line">        <span class="keyword">if</span> (greetingCounter == max) &#123;</span><br><span class="line">            <span class="keyword">return</span> Behaviors.stopped();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            message.from.tell(<span class="keyword">new</span> Greeter.Greet(message.whom, getContext().getSelf()));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.ActorRef;</span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.Behavior;</span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.javadsl.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreeterMain</span> <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>&lt;<span class="title">GreeterMain</span>.<span class="title">SayHello</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActorRef&lt;Greeter.Greet&gt; greeter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Behavior&lt;SayHello&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Behaviors.setup(GreeterMain::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GreeterMain</span><span class="params">(ActorContext&lt;SayHello&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        <span class="comment">//#create-actors</span></span><br><span class="line">        greeter = context.spawn(Greeter.create(), <span class="string">"greeter"</span>);</span><br><span class="line">        <span class="comment">//#create-actors</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Receive&lt;SayHello&gt; <span class="title">createReceive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newReceiveBuilder().onMessage(SayHello.class, <span class="keyword">this</span>::onSayHello).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Behavior&lt;SayHello&gt; <span class="title">onSayHello</span><span class="params">(SayHello command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//#create-actors</span></span><br><span class="line">        ActorRef&lt;Greeter.Greeted&gt; replyTo =</span><br><span class="line">                getContext().spawn(GreeterBot.create(<span class="number">3</span>), command.name);</span><br><span class="line">        greeter.tell(<span class="keyword">new</span> Greeter.Greet(command.name, replyTo));</span><br><span class="line">        <span class="comment">//#create-actors</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Actor class [cn.wkq.java.akka.AkkaDemo$HelloActor] must be subClass of akka.actor.Actor or akka.actor.IndirectActorProducer.</span><br><span class="line">at akka.actor.AbstractProps.validate(AbstractProps.scala:31)</span><br></pre></td></tr></table></figure><h1 id="Rferences"><a href="#Rferences" class="headerlink" title="Rferences"></a>Rferences</h1><p>[1] <a href="https://time.geekbang.org/column/article/98903" target="_blank" rel="noopener">42 | Actor模型：面向对象原生的并发模型</a><br>[2] <a href="https://doc.akka.io/docs/akka/current/index.html" target="_blank" rel="noopener">doc.akka.io/docs/akka/current</a><br>[3] <a href="https://github.com/guobinhit/akka-guide" target="_blank" rel="noopener">akka-guide</a><br>[4] <a href="https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html" target="_blank" rel="noopener">Why modern systems need a new programming model</a><br>[5] <a href="https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html" target="_blank" rel="noopener">How the Actor Model Meets the Needs of Modern, Distributed Systems</a><br>[6] <a href="https://doc.akka.io/docs/akka/2.2/AkkaJava.pdf" target="_blank" rel="noopener">doc.akka.io/docs/akka/2.2/AkkaJava.pdf</a><br>[7] <a href="https://developer.lightbend.com/guides/akka-quickstart-java/" target="_blank" rel="noopener">guides/akka-quickstart-java</a><br>[8] <a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-quickstart-java" target="_blank" rel="noopener">akka-quickstart-java</a><br>[9] <a href="https://github.com/mpeltonen/sbt-idea" target="_blank" rel="noopener">sbt-idea</a><br>[10] <a href="https://blog.csdn.net/qq_35246620/article/details/79050895" target="_blank" rel="noopener">快速入门 Akka Java 指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; Akka is a toolkit and runtime for building highly concurrent, distributed, and fault-tolerant event-driven applications on the JVM. Akka can be used with both Java and Scala. This guide introduces Akka by describing the Java version of the Hello World example. If you prefer to use Akka with Scala, switch to the Akka Quickstart with Scala guide.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Actors are the unit of execution in Akka. The Actor model is an abstraction that makes it easier to write correct concurrent, parallel and distributed systems. The Hello World example illustrates Akka basics. Within 30 minutes, you should be able to download and run the example and use this guide to understand how the example is constructed. This will get your feet wet, and hopefully inspire you to dive deeper into the wonderful sea of Akka!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;解决了什么问题&quot;&gt;&lt;a href=&quot;#解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;解决了什么问题&quot;&gt;&lt;/a&gt;解决了什么问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; Akka是Actor模型的一种实现&lt;br&gt; Actor模型解决了 传统编程假设与现代多线程、多CPU架构的现实之间的不匹配问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息传递的使用避免了锁和阻塞。  &lt;/li&gt;
&lt;li&gt;Actor能够优化地处理错误情况。 &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Usage of message passing avoids locking and blocking.&lt;br&gt; Actors handle error situations gracefully&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt; OOP在构建苛刻需求的分布式系统会遇到的问题 &lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;并发情况下封装导致效率问题和死锁问题。&lt;/li&gt;
&lt;li&gt;并发时共享内存失效(CPU缓存失效导致)导致效率低的问题。&lt;/li&gt;
&lt;li&gt;调用栈导致的后台线程在异常时的通信问题以及后续问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The challenge of encapsulation&lt;/li&gt;
&lt;li&gt;The illusion of shared memory on modern computer architectures&lt;/li&gt;
&lt;li&gt;The illusion of a call stack&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://weikeqin.com/categories/java/"/>
    
    
      <category term="java" scheme="http://weikeqin.com/tags/java/"/>
    
      <category term="concurrent" scheme="http://weikeqin.com/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>jvm-config</title>
    <link href="http://weikeqin.com/2020/06/09/jvm-config/"/>
    <id>http://weikeqin.com/2020/06/09/jvm-config/</id>
    <published>2020-06-09T12:30:28.000Z</published>
    <updated>2020-08-07T08:51:03.915Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep HeapSize  <span class="comment"># 查看堆内存配置的默认值</span></span><br><span class="line">jmap -heap pid</span><br></pre></td></tr></table></figure><h1 id="常用的JVM配置"><a href="#常用的JVM配置" class="headerlink" title="常用的JVM配置"></a>常用的JVM配置</h1><p>  <code>-client</code> The client VM is tuned for reducing start-up time and memory footprint. Invoke it by using the -client JVM command-line option.<br>  <code>-server</code> The server VM is designed for maximum program execution speed. Invoke it by using the -server JVM command-line option.</p><p>  <code>-Dfile.encoding=UTF-8</code> 文件使用UTF-8编码<br>  <code>-Xms2g</code> = <code>-XX:InitialHeapSize=2g</code> = <code>-XX:MinHeapSize=2g</code> 设置初始堆大小为2G<br>  <code>-Xmx2g</code> = <code>-XX:MaxHeapSize=2g</code> 设置最大堆大小为2G<br>  <code>-Xmn1g</code> 设置新生代大小为1G </p><p>  <code>-XX:MinHeapFreeRatio=</code><br>  <code>-XX:MaxHeapFreeRatio=</code><br>  <code>-XX:NewRatio</code><br>  <code>-XX:NewSize</code><br>  <code>-XX:MaxNewSize</code><br>  <code>-XX:+AggressiveHeap</code><br>  <code></code><br>  <code></code><br>  <code></code><br>  <code></code></p><p>  <code>-Xss256k</code>  设置每个线程的堆栈大小，和栈的深度和容器创建的最大线程数有关</p><p>  <code>-XX:LargePageSizeInBytes=128m</code>  内存页的大小不可设置过大， 会影响Perm的大小<br>  <code>-XX:MaxDirectMemorySize=536870912</code> </p><p>  <code>-XX:+UseFastAccessorMethods</code>  原始类型的快速优化</p><p>  <code>-XX:PetenureSizeThreshold=</code> 设置直接被分配到老年代的最大阀值 </p><p>  <code>-XX:+TraceClassLoading</code> 打印类加载信息</p><h1 id="配置垃圾回收算法"><a href="#配置垃圾回收算法" class="headerlink" title="配置垃圾回收算法"></a>配置垃圾回收算法</h1><p> -XX:+UseG1GC 使用G1垃圾收集器</p><h1 id="gc配置"><a href="#gc配置" class="headerlink" title="gc配置"></a>gc配置</h1><p>  <code>-XX:+PrintGC</code>  用于垃圾收集时的信息打印   -verbosegc (which is equivalent to -XX:+PrintGC) sets the detail level of the log to fine.<br>  <code>-XX:+PrintGCDetails</code>  打印GC详细信息   ets the detail level to finer.<br>  <code>-XX:+PrintGCTimeStamps</code>  输出GC的时间戳（以基准时间的形式 245469.1 ）<br>  <code>-XX:+PrintGCDateStamps</code>  输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）<br>  <code>-XX:+HeapDumpBeforeFullGC</code> FullGC前保存堆栈信息  测试环境使用，线上最好别用，小心磁盘被打满<br>  <code>-XX:+HeapDumpAfterFullGC</code>  FullGC后保存堆栈信息  测试环境使用，线上最好别用，小心磁盘被打满</p><p>  <code>-XX:+DisableExplicitGC</code>  禁止代码中显示调用GC<br>  <code>-Xloggc:filename</code>  gc日志保存到指定文件 把filename替换成 /home/admin/gc.log</p><p>  <code>-XX:+HeapDumpOnOutOfMemoryError</code> OOM后保存堆栈信息<br>  <code>-XX:-OmitStackTraceInFastThrow</code> 当大量抛出同样的异常的后，后面的异常输出将不打印堆栈<br>  <code>-XX:ErrorFile=logs/hs_err_pid%p.log</code> </p><h1 id="JIT-config"><a href="#JIT-config" class="headerlink" title="JIT config"></a>JIT config</h1><blockquote><p> JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM会尝试将其编译为机器码，从而提高执行速度。</p></blockquote><blockquote><p> 在 Java8 之前，HotSpot 集成了两个 JIT，用 C1 和 C2 来完成 JVM 中的即时编译。<br> 到了 Java9，AOT 编译器被引入。AOT 是在程序运行前进行的静态编译，这样就可以避免运行时的编译消耗和内存消耗，且 .class 文件通过 AOT 编译器是可以编译成 .so 的二进制文件的。<br> Java10，一个新的 JIT 编译器 Graal 被引入。Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++ 实现的 C1 和 C2 相比，它的模块化更加明显，也更容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；也可以作为静态编译器，实现 AOT 编译。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#CompileThreshold must be between 0 and 268435455</span><br><span class="line">-XX:CompileThreshold=128</span><br></pre></td></tr></table></figure><blockquote><p> 方法调用计数器：用于统计方法被调用的次数<br> 方法调用计数器的默认阈值在 C1 模式下是 1500 次，在 C2 模式在是 10000 次，可通过 -XX:CompileThreshold 来设定；而在分层编译的情况下，-XX:CompileThreshold 指定的阈值将失效，此时将会根据当前待编译的方法数以及编译线程数来动态调整。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:OnStackReplacePercentage=10000</span><br></pre></td></tr></table></figure><p>回边计数器：用于统计一个方法中循环体代码执行的次数，</p><p>在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge），该值用于计算是否触发 C1 编译的阈值，在不开启分层编译的情况下，C1 默认为 13995，C2 默认为 10700，可通过 -XX: OnStackReplacePercentage=N 来设置；而在分层编译的情况下，-XX: OnStackReplacePercentage 指定的阈值同样会失效，此时将根据当前待编译的方法数以及编译线程数来动态调整。</p><p>在一些循环周期比较长的代码段中，当循环达到回边计数器阈值时，JVM 会认为这段是热点代码，JIT 编译器就会将这段代码编译成机器语言并缓存，在该循环时间段内，会直接将执行代码替换，执行缓存的机器语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CICompilerCount=2</span><br></pre></td></tr></table></figure><p>经常执行的方法，默认情况下，方法体大小小于 325 字节的都会进行内联，我们可以通过 -XX:MaxFreqInlineSize=N 来设置大小值；<br>不是经常执行的方法，默认情况下，方法大小小于 35 字节才会进行内联，我们也可以通过 -XX:MaxInlineSize=N 来重置大小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation //在控制台打印编译过程信息</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions //解锁对JVM进行诊断的选项参数。默认是关闭的，开启后支持一些特定参数对JVM进行诊断</span><br><span class="line">-XX:+PrintInlining //将内联方法打印出来</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="CMS垃圾回收器配置"><a href="#CMS垃圾回收器配置" class="headerlink" title="CMS垃圾回收器配置"></a>CMS垃圾回收器配置</h1><p>  Eden            –|<br>  Survior0 Space  —- Young Generation<br>  Survior1 Space  –|</p><p>  Old Generation<br>  Permanent Generation</p><p>  <code>-XX:+UseConcMarkSweepGC</code>    使用CMS垃圾收集器<br>  <code>-XX:+CMSParallelRemarkEnabled</code>  降低标记停顿<br>  <code>-XX:CMSFullGCsBeforeCompaction=*</code><br>  <code>-XX:+UseCMSCompactAtFullCollection</code>  在FullGC的时候 对年老代的压缩<br>  <code>-XX:CMSInitiatingOccupancyFraction=75</code>  CMS垃圾收集会在老年代被占用75%时被触发<br>  <code>-XX:+UseCMSInitiatingOccupancyOnly</code>  基于运行时收集的数据来启动CMS垃圾收集周期</p><h1 id="G1垃圾收集器配置"><a href="#G1垃圾收集器配置" class="headerlink" title="G1垃圾收集器配置"></a>G1垃圾收集器配置</h1><p>  Ende Space<br>  Survivor Space<br>  Oid Generation</p><table><thead><tr><th style="text-align:left">Option and Default Value</th><th style="text-align:left">描述</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>-XX:+UseG1GC</code></td><td style="text-align:left">使用G1垃圾收集器</td><td style="text-align:left">Use the Garbage First (G1) Collector</td></tr><tr><td style="text-align:left"><code>-XX:MaxGCPauseMillis=200</code></td><td style="text-align:left">设置G1收集过程目标时间，默认值200ms</td><td style="text-align:left">Sets a target for the maximum GC pause time. This is a soft goal, and the JVM will make its best effort to achieve it.</td></tr><tr><td style="text-align:left"><code>-XX:InitiatingHeapOccupancyPercent=30</code></td><td style="text-align:left">设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous</td><td style="text-align:left">Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A value of 0 denotes ‘do constant GC cycles’. The default value is 45.</td></tr><tr><td style="text-align:left"><code>-XX:NewRatio=2</code></td><td style="text-align:left">新生代 老年代 比例</td><td style="text-align:left">Ratio of new/old generation sizes. The default value is 2.</td></tr><tr><td style="text-align:left"><code>-XX:SurvivorRatio=8</code></td><td style="text-align:left">Eden区 Survivor区 比例</td><td style="text-align:left">Ratio of eden/survivor space size. The default value is 8.</td></tr><tr><td style="text-align:left"><code>-XX:MaxTenuringThreshold=15</code></td><td style="text-align:left">新生代最大需要经历多少次GC晋升到老年代。</td><td style="text-align:left">Maximum value for tenuring threshold. The default value is 15.</td></tr><tr><td style="text-align:left"><code>-XX:ParallelGCThreads=2</code></td><td style="text-align:left">设置在垃圾回收器的并行阶段使用的线程数。</td><td style="text-align:left">Sets the number of threads used during parallel phases of the garbage collectors. The default value varies with the platform on which the JVM is running.</td></tr><tr><td style="text-align:left"><code>-XX:ConcGCThreads=2</code></td><td style="text-align:left">并发垃圾收集器将使用的线程数。</td><td style="text-align:left">Number of threads concurrent garbage collectors will use. The default value varies with the platform on which the JVM is running.</td></tr><tr><td style="text-align:left"><code>-XX:G1ReservePercent=10</code></td><td style="text-align:left">设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险</td><td style="text-align:left">Sets the amount of heap that is reserved as a false ceiling to reduce the possibility of promotion failure. The default value is 10.</td></tr><tr><td style="text-align:left"><code>-XX:G1HeapRegionSize=25</code></td><td style="text-align:left">设置Region大小</td><td style="text-align:left">With G1 the Java heap is subdivided into uniformly sized regions. This sets the size of the individual sub-divisions. The default value of this parameter is determined ergonomically based upon heap size. The minimum value is 1Mb and the maximum value is 32Mb.</td></tr></tbody></table><h2 id="G1-Log"><a href="#G1-Log" class="headerlink" title="G1 Log"></a>G1 Log</h2><p>  <code>-verbosegc</code> (which is equivalent to -XX:+PrintGC) sets the detail level of the log to fine.<br>  <code>-XX:+PrintGCDetails</code>  sets the detail level to finer.<br>  <code>-XX:+UnlockExperimentalVMOptions -XX:G1LogLevel=finest</code>  sets the detail level to its finest. Like finer but includes individual worker thread information.<br>  <code>-XX:+PrintGCTimeStamps</code>  Shows the elapsed time since the JVM started.<br>  <code>-XX:+PrintGCDateStamps</code>  Adds a time of day prefix to each entry.</p><h1 id="ZGC-垃圾回收器配置"><a href="#ZGC-垃圾回收器配置" class="headerlink" title="ZGC 垃圾回收器配置"></a>ZGC 垃圾回收器配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-XX:MinHeapSize, -Xms</span><br><span class="line">-XX:InitialHeapSize, -Xms</span><br><span class="line">-XX:MaxHeapSize, -Xmx</span><br><span class="line">-XX:SoftMaxHeapSize</span><br><span class="line">-XX:ConcGCThreads</span><br><span class="line">-XX:ParallelGCThreads</span><br><span class="line">-XX:UseLargePages</span><br><span class="line">-XX:UseTransparentHugePages</span><br><span class="line">-XX:UseNUMA</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB</span><br><span class="line">-XX:AllocateHeapAt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-XX:ZAllocationSpikeTolerance</span><br><span class="line"></span><br><span class="line">-XX:ZCollectionInterval</span><br><span class="line"></span><br><span class="line">-XX:ZFragmentationLimit</span><br><span class="line"></span><br><span class="line">-XX:ZMarkStackSpaceLimit</span><br><span class="line"></span><br><span class="line">-XX:ZProactive</span><br><span class="line"></span><br><span class="line">-XX:ZUncommit</span><br><span class="line"></span><br><span class="line">-XX:ZUncommitDelay</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Lock-config"><a href="#Lock-config" class="headerlink" title="Lock config"></a>Lock config</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseBiasedLocking //关闭偏向锁</span><br><span class="line">-XX:+UseHeavyMonitors  //设置重量级锁</span><br><span class="line">-XX:-UseSpinning //参数关闭自旋锁优化(默认打开) </span><br><span class="line">-XX:PreBlockSpin //参数修改默认的自旋次数。JDK1.7后，去掉此参数，由jvm控制</span><br></pre></td></tr></table></figure><p> <code>-XX:-UseBiasedLocking</code>  关闭偏向锁</p><blockquote><p>在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生 stop the word 后， 开启偏向锁会带来更大的性能开销</p></blockquote><h1 id="XX-RestrictContended"><a href="#XX-RestrictContended" class="headerlink" title="-XX:-RestrictContended"></a>-XX:-RestrictContended</h1><blockquote><p> 避免伪共享<br> 多线程并发条件下，volite变量导致CPU缓存里的数据和主内存的数据不一致导致CPU缓存失效。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-RestrictContended</span><br></pre></td></tr></table></figure><p>  避免伪共享是以牺牲内存为代价的</p><blockquote><p> 伪共享和 CPU 内部的 Cache 有关，Cache 内部是按照缓存行（Cache Line）管理的，缓存行的大小通常是 64 个字节；CPU 从内存中加载数据 X，会同时加载 X 后面（64-size(X)）个字节的数据。<br> 避免伪共享很简单，每个变量x独占一个缓存行、不共享缓存行就可以了，具体技术是缓存行填充。<br> 比如想让 变量x 独占一个缓存行，可以在 变量x 的前后各填充 64-size(x) 个字节，这样就一定能保证 变量x 独占一个缓存行。</p></blockquote><p>  由于伪共享问题如此重要，所以 Java 也开始重视它了，比如 Java 8 中，提供了避免伪共享的注解：@sun.misc.Contended，通过这个注解就能轻松避免伪共享（需要设置 JVM 参数 -XX:-RestrictContended）。不过避免伪共享是以牺牲内存为代价的</p><p><a href="https://time.geekbang.org/column/article/98134" target="_blank" rel="noopener">40 | 案例分析（三）：高性能队列Disruptor</a></p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>  逃逸分析（Escape Analysis）是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis //开启逃逸分析（jdk1.8默认开启）</span><br><span class="line">-XX:-DoEscapeAnalysis //关闭逃逸分析</span><br></pre></td></tr></table></figure><h2 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h2><p>逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。这种编译优化就叫做标量替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     TestInfo info = <span class="keyword">new</span> TestInfo();</span><br><span class="line">     info.id = <span class="number">1</span>;</span><br><span class="line">     info.count = <span class="number">99</span>;</span><br><span class="line">       ...<span class="comment">//to do something</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     id = <span class="number">1</span>;</span><br><span class="line">     count = <span class="number">99</span>;</span><br><span class="line">     ...<span class="comment">//to do something</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-XX:+EliminateLocks //开启锁消除（jdk1.8默认开启）</span><br><span class="line">-XX:-EliminateLocks //关闭锁消除</span><br><span class="line"></span><br><span class="line">-XX:+EliminateAllocations //开启标量替换（jdk1.8默认开启）</span><br><span class="line">-XX:-EliminateAllocations //关闭标量替换</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://docs.oracle.com/cd/E19159-01/819-3681/6n5srlhqc/index.html" target="_blank" rel="noopener">Chapter 4 Tuning the Java Runtime System</a><br>[2] <a href="https://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">java</a><br>[3] <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" target="_blank" rel="noopener">8 Concurrent Mark Sweep (CMS) Collector</a><br>[4] <a href="http://ifeve.com/useful-jvm-flags-part-7-cms-collector/" target="_blank" rel="noopener">JVM实用参数（七）CMS收集器</a><br>[5] <a href="https://tech.meituan.com/2016/09/23/g1.html" target="_blank" rel="noopener">Java Hotspot G1 GC的一些关键技术</a><br>[6] <a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a><br>[7] <a href="https://wiki.openjdk.java.net/display/zgc/Main" target="_blank" rel="noopener">ZGC官网</a><br>[8] <a href="https://panlw.github.io/15320998566522.html" target="_blank" rel="noopener">关键系统的JVM参数推荐(2018仲夏版)</a><br>[9] <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">github.com/alibaba/arthas</a><br>[10] <a href="https://github.com/vipshop/vjtools" target="_blank" rel="noopener">github.com/vipshop/vjtools</a><br>[11] <a href="https://www.rowkey.me/blog/2017/03/23/java-profile-cheatsheet/" target="_blank" rel="noopener">JVM诊断调优CheatSheet</a><br>[12] <a href="https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/" target="_blank" rel="noopener">understanding-jit-compiler-just-in-time-compiler</a><br>[13] <a href="https://stackoverflow.com/questions/51154464/should-heapdumpbeforefullgc-be-used-in-production-environment" target="_blank" rel="noopener">should-heapdumpbeforefullgc-be-used-in-production-environment</a><br>[14]<a href="https://time.geekbang.org/column/article/101244" target="_blank" rel="noopener">12 | 多线程之锁优化（上）：深入了解Synchronized同步锁的优化方法</a><br>[15] [可能是最全面的G1学习笔记( <a href="https://www.jianshu.com/p/a3e6a9de7a5d" target="_blank" rel="noopener">https://www.jianshu.com/p/a3e6a9de7a5d</a> )</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -XX:+PrintFlagsFinal -version | grep HeapSize  &lt;span class=&quot;comment&quot;&gt;# 查看堆内存配置的默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jmap -heap pid&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;常用的JVM配置&quot;&gt;&lt;a href=&quot;#常用的JVM配置&quot; class=&quot;headerlink&quot; title=&quot;常用的JVM配置&quot;&gt;&lt;/a&gt;常用的JVM配置&lt;/h1&gt;&lt;p&gt;  &lt;code&gt;-client&lt;/code&gt; The client VM is tuned for reducing start-up time and memory footprint. Invoke it by using the -client JVM command-line option.&lt;br&gt;  &lt;code&gt;-server&lt;/code&gt; The server VM is designed for maximum program execution speed. Invoke it by using the -server JVM command-line option.&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;-Dfile.encoding=UTF-8&lt;/code&gt; 文件使用UTF-8编码&lt;br&gt;  &lt;code&gt;-Xms2g&lt;/code&gt; = &lt;code&gt;-XX:InitialHeapSize=2g&lt;/code&gt; = &lt;code&gt;-XX:MinHeapSize=2g&lt;/code&gt; 设置初始堆大小为2G&lt;br&gt;  &lt;code&gt;-Xmx2g&lt;/code&gt; = &lt;code&gt;-XX:MaxHeapSize=2g&lt;/code&gt; 设置最大堆大小为2G&lt;br&gt;  &lt;code&gt;-Xmn1g&lt;/code&gt; 设置新生代大小为1G &lt;/p&gt;
&lt;p&gt;  &lt;code&gt;-XX:MinHeapFreeRatio=&lt;/code&gt;&lt;br&gt;  &lt;code&gt;-XX:MaxHeapFreeRatio=&lt;/code&gt;&lt;br&gt;  &lt;code&gt;-XX:NewRatio&lt;/code&gt;&lt;br&gt;  &lt;code&gt;-XX:NewSize&lt;/code&gt;&lt;br&gt;  &lt;code&gt;-XX:MaxNewSize&lt;/code&gt;&lt;br&gt;  &lt;code&gt;-XX:+AggressiveHeap&lt;/code&gt;&lt;br&gt;  &lt;code&gt;&lt;/code&gt;&lt;br&gt;  &lt;code&gt;&lt;/code&gt;&lt;br&gt;  &lt;code&gt;&lt;/code&gt;&lt;br&gt;  &lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;-Xss256k&lt;/code&gt;  设置每个线程的堆栈大小，和栈的深度和容器创建的最大线程数有关&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;-XX:LargePageSizeInBytes=128m&lt;/code&gt;  内存页的大小不可设置过大， 会影响Perm的大小&lt;br&gt;  &lt;code&gt;-XX:MaxDirectMemorySize=536870912&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;  &lt;code&gt;-XX:+UseFastAccessorMethods&lt;/code&gt;  原始类型的快速优化&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;-XX:PetenureSizeThreshold=&lt;/code&gt; 设置直接被分配到老年代的最大阀值 &lt;/p&gt;
&lt;p&gt;  &lt;code&gt;-XX:+TraceClassLoading&lt;/code&gt; 打印类加载信息&lt;/p&gt;
&lt;h1 id=&quot;配置垃圾回收算法&quot;&gt;&lt;a href=&quot;#配置垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;配置垃圾回收算法&quot;&gt;&lt;/a&gt;配置垃圾回收算法&lt;/h1&gt;&lt;p&gt; -XX:+UseG1GC 使用G1垃圾收集器&lt;/p&gt;
&lt;h1 id=&quot;gc配置&quot;&gt;&lt;a href=&quot;#gc配置&quot; class=&quot;headerlink&quot; title=&quot;gc配置&quot;&gt;&lt;/a&gt;gc配置&lt;/h1&gt;&lt;p&gt;  &lt;code&gt;-XX:+PrintGC&lt;/code&gt;  用于垃圾收集时的信息打印   -verbosegc (which is equivalent to -XX:+PrintGC) sets the detail level of the log to fine.&lt;br&gt;  &lt;code&gt;-XX:+PrintGCDetails&lt;/code&gt;  打印GC详细信息   ets the detail level to finer.&lt;br&gt;  &lt;code&gt;-XX:+PrintGCTimeStamps&lt;/code&gt;  输出GC的时间戳（以基准时间的形式 245469.1 ）&lt;br&gt;  &lt;code&gt;-XX:+PrintGCDateStamps&lt;/code&gt;  输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）&lt;br&gt;  &lt;code&gt;-XX:+HeapDumpBeforeFullGC&lt;/code&gt; FullGC前保存堆栈信息  测试环境使用，线上最好别用，小心磁盘被打满&lt;br&gt;  &lt;code&gt;-XX:+HeapDumpAfterFullGC&lt;/code&gt;  FullGC后保存堆栈信息  测试环境使用，线上最好别用，小心磁盘被打满&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;-XX:+DisableExplicitGC&lt;/code&gt;  禁止代码中显示调用GC&lt;br&gt;  &lt;code&gt;-Xloggc:filename&lt;/code&gt;  gc日志保存到指定文件 把filename替换成 /home/admin/gc.log&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt; OOM后保存堆栈信息&lt;br&gt;  &lt;code&gt;-XX:-OmitStackTraceInFastThrow&lt;/code&gt; 当大量抛出同样的异常的后，后面的异常输出将不打印堆栈&lt;br&gt;  &lt;code&gt;-XX:ErrorFile=logs/hs_err_pid%p.log&lt;/code&gt; &lt;/p&gt;
&lt;h1 id=&quot;JIT-config&quot;&gt;&lt;a href=&quot;#JIT-config&quot; class=&quot;headerlink&quot; title=&quot;JIT config&quot;&gt;&lt;/a&gt;JIT config&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM会尝试将其编译为机器码，从而提高执行速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 在 Java8 之前，HotSpot 集成了两个 JIT，用 C1 和 C2 来完成 JVM 中的即时编译。&lt;br&gt; 到了 Java9，AOT 编译器被引入。AOT 是在程序运行前进行的静态编译，这样就可以避免运行时的编译消耗和内存消耗，且 .class 文件通过 AOT 编译器是可以编译成 .so 的二进制文件的。&lt;br&gt; Java10，一个新的 JIT 编译器 Graal 被引入。Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++ 实现的 C1 和 C2 相比，它的模块化更加明显，也更容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；也可以作为静态编译器，实现 AOT 编译。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#CompileThreshold must be between 0 and 268435455&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:CompileThreshold=128&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt; 方法调用计数器：用于统计方法被调用的次数&lt;br&gt; 方法调用计数器的默认阈值在 C1 模式下是 1500 次，在 C2 模式在是 10000 次，可通过 -XX:CompileThreshold 来设定；而在分层编译的情况下，-XX:CompileThreshold 指定的阈值将失效，此时将会根据当前待编译的方法数以及编译线程数来动态调整。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:OnStackReplacePercentage=10000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;回边计数器：用于统计一个方法中循环体代码执行的次数，&lt;/p&gt;
&lt;p&gt;在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge），该值用于计算是否触发 C1 编译的阈值，在不开启分层编译的情况下，C1 默认为 13995，C2 默认为 10700，可通过 -XX: OnStackReplacePercentage=N 来设置；而在分层编译的情况下，-XX: OnStackReplacePercentage 指定的阈值同样会失效，此时将根据当前待编译的方法数以及编译线程数来动态调整。&lt;/p&gt;
&lt;p&gt;在一些循环周期比较长的代码段中，当循环达到回边计数器阈值时，JVM 会认为这段是热点代码，JIT 编译器就会将这段代码编译成机器语言并缓存，在该循环时间段内，会直接将执行代码替换，执行缓存的机器语言。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:CICompilerCount=2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;经常执行的方法，默认情况下，方法体大小小于 325 字节的都会进行内联，我们可以通过 -XX:MaxFreqInlineSize=N 来设置大小值；&lt;br&gt;不是经常执行的方法，默认情况下，方法大小小于 35 字节才会进行内联，我们也可以通过 -XX:MaxInlineSize=N 来重置大小值&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:+PrintCompilation //在控制台打印编译过程信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:+UnlockDiagnosticVMOptions //解锁对JVM进行诊断的选项参数。默认是关闭的，开启后支持一些特定参数对JVM进行诊断&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:+PrintInlining //将内联方法打印出来&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://weikeqin.com/categories/jvm/"/>
    
    
      <category term="java" scheme="http://weikeqin.com/tags/java/"/>
    
      <category term="jvm" scheme="http://weikeqin.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java并发设计模式</title>
    <link href="http://weikeqin.com/2020/06/07/java-concurrent-design-pattern/"/>
    <id>http://weikeqin.com/2020/06/07/java-concurrent-design-pattern/</id>
    <published>2020-06-07T09:03:36.000Z</published>
    <updated>2020-06-13T03:49:41.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 多线程设计模式是前人解决并发问题的经验总结，当我们试图解决一个并发问题时，首选方案往往是使用匹配的设计模式，这样能避免走弯路。<br> 大家都熟悉设计模式，所以使用设计模式还能提升方案和代码的可理解性。</p></blockquote><blockquote><p>避免共享的设计模式<br><code>Immutability 模式</code>、<code>Copy-on-Write 模式</code> 和 <code>线程本地存储模式</code> 本质上都是为了避免共享，只是实现手段不同而已。</p></blockquote><blockquote><p> 多线程版本IF的设计模式<br> <code>Guarded Suspension 模式</code> 和 <code>Balking 模式</code> 都可以简单地理解为“多线程版本的 if”，但它们的区别在于前者会等待 if 条件变为真，而后者则不需要等待。</p></blockquote><blockquote><p> 三种最简单的分工模式<br> <code>Thread-Per-Message模式</code> 、 <code>Worker Thread 模式</code> 和 <code>生产者-消费者模式</code> 是三种最简单实用的多线程分工方法</p></blockquote><h1 id="1-Immutability-Pattern-不变性模式"><a href="#1-Immutability-Pattern-不变性模式" class="headerlink" title="(1) Immutability Pattern 不变性模式"></a>(1) Immutability Pattern 不变性模式</h1><blockquote><p> 解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。</p></blockquote><blockquote><p> 不变性（Immutability）模式。所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。</p></blockquote><blockquote><p> Java SDK 里很多类都具备不可变性。例如经常用到的 String 和 Long、Integer、Double 等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。仔细翻看这些类的声明、属性和方法，你会发现它们都严格遵守不可变类的三点要求：类和属性都是 final 的，所有方法均是只读的。</p></blockquote><blockquote><p> Java所有的基础类型的包装类都不适合做锁，因为它们内部用到了享元模式，这会导致看上去私有的锁，其实是共有的。</p></blockquote><blockquote><p> 使用 Immutability 模式的注意事项在使用 Immutability 模式的时候，需要注意以下两点：</p><ol><li>对象的所有属性都是 final 的，并不能保证不可变性；</li><li>不可变对象也需要正确发布。 </li></ol></blockquote><blockquote><p> 在使用 Immutability 模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性。<br> Foo对象是不变的，但是Foo对象的属性是可以变化的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> name=<span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Foo foo;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    foo.age=a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><blockquote><p> 不可变对象虽然是线程安全的，但是并不意味着引用这些不可变对象的对象就是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Foo线程安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> age=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> name=<span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bar线程不安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setFoo</span><span class="params">(Foo f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo=f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="2-Copy-on-Write-Parrent-写时复制模式"><a href="#2-Copy-on-Write-Parrent-写时复制模式" class="headerlink" title="(2) Copy-on-Write Parrent 写时复制模式"></a>(2) Copy-on-Write Parrent 写时复制模式</h1><blockquote><p> Java 里 String 这个类在实现 replace() 方法的时候，并没有更改原字符串里面 value[]数组的内容，而是创建了一个新字符串，这种方法在解决不可变对象的修改问题时经常用到。<br> Copy-on-Write，经常被缩写为 COW 或者 CoW，顾名思义就是写时复制。<br> 不可变对象的写操作往往都是使用 Copy-on-Write 方法解决的。</p></blockquote><blockquote><p> Java 提供的 Copy-on-Write 容器，由于在修改的同时会复制整个容器，所以在提升读操作性能的同时，是以内存复制为代价的。</p></blockquote><blockquote><p> CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个 Copy-on-Write 容器，它们背后的设计思想就是 Copy-on-Write；<br> 类Unix操作系统fork()函数<br> Docker 容器镜像的设计是 Copy-on-Write<br> 分布式源码管理系统 Git 背后的设计思想都有 Copy-on-Write<br> 函数式编程里面所有的修改操作都需要 Copy-on-Write 来解决 (按需复制)</p></blockquote><p>《Purely Functional Data Structures》</p><blockquote><p> Java 提供了 CopyOnWriteArrayList，为什么没有提供 CopyOnWriteLinkedList 呢？</p><ol><li>没有提供CopyOnWriteLinkedList是因为linkedlist的数据结构关系分散到每一个节点里面，对每一个节点的修改都存在竟态条件，需要同步才能保证一致性。arraylist就不一样，数组天然的拥有前驱后继的结构关系，对列表的增删，因为是copy on wirte，所以只需要cas操作数组对象就能够保证线程安全，效率上也能接受，更重要的是避免锁竞争带来的上下文切换消耗。有一点需要注意的是CopyOnWriteArrayList在使用上有数据不完整的时间窗口，要不要考虑需要根据具体场景定夺。</li><li>链表的新增删除压根就不需要复制，就算是在并发场景下采用锁的方式性能损耗都不大，因此也就没必要采用copy的方式了，更何况链表的操作可以采用分段锁、节点锁。所以没有CopyOnWriteLinkedList的主要原因是没有这个必要。</li><li>ArrayList 是用是数组实现的, 在内存上时一块连续的区域, 拷贝时效率比较高, 时间复杂度为 O(1)</li><li>LinkedList 是链表实现, 其数据是通过指针串联起来的, 并非一块连续的区域, 拷贝时必须要进行遍历操作, 效率比较低, 时间复杂度是 O(n)</li><li>CopyOnWriteLinkedList的链表结构读取效率比较低，就违背了读多写少的设计初衷。</li></ol></blockquote><h1 id="3-ThreadLocal-线程本地存储"><a href="#3-ThreadLocal-线程本地存储" class="headerlink" title="(3) ThreadLocal 线程本地存储"></a>(3) ThreadLocal 线程本地存储</h1><blockquote><p> 线程本地存储模式本质上是一种避免共享的方案，由于没有共享，所以自然也就没有并发问题。</p></blockquote><blockquote><p> 避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式</p></blockquote><h1 id="4-Guarded-Suspension-模式"><a href="#4-Guarded-Suspension-模式" class="headerlink" title="(4) Guarded Suspension 模式"></a>(4) Guarded Suspension 模式</h1><blockquote><p> Guarded Suspension 模式本质上是一种等待唤醒机制的实现，只不过 Guarded Suspension 模式将其规范化了。</p></blockquote><blockquote><p> Guarded Suspension 模式也常被称作 Guarded Wait 模式、Spin Lock 模式（因为使用了 while 循环去等待），这些名字都很形象，不过它还有一个更形象的非官方名字：多线程版本的 if。</p></blockquote><h1 id="5-Balking模式"><a href="#5-Balking模式" class="headerlink" title="(5) Balking模式"></a>(5) Balking模式</h1><blockquote><p> Balking 模式和 Guarded Suspension 模式从实现上看似乎没有多大的关系，Balking 模式只需要用互斥锁就能解决，而 Guarded Suspension 模式则要用到管程这种高级的并发原语；</p></blockquote><blockquote><p> 从应用的角度来看，它们解决的都是“线程安全的 if”语义，不同之处在于，Guarded Suspension 模式会等待 if 条件为真，而 Balking 模式不会等待。</p></blockquote><h1 id="6-Thread-Per-Message模式"><a href="#6-Thread-Per-Message模式" class="headerlink" title="(6) Thread-Per-Message模式"></a>(6) Thread-Per-Message模式</h1><blockquote><p> 委托他人办理的方式，在并发编程领域被总结为一种设计模式，叫做 Thread-Per-Message 模式，简言之就是为每个任务分配一个独立的线程。这是一种最简单的分工方法。</p></blockquote><blockquote><p> 你委托代办人做事，往往是和代办人直接沟通的；对应到编程领域，其实现也是主线程直接创建了一个子线程，主子线程之间是可以直接通信的。</p></blockquote><blockquote><p> Thread-Per-Message 模式在 Java 领域并不是那么知名，根本原因在于 Java 语言里的线程是一个重量级的对象，为每一个任务创建一个线程成本太高，尤其是在高并发领域，基本就不具备可行性。</p></blockquote><blockquote><p> Thread-Per-Message 模式在实现的时候需要注意是否存在线程的频繁创建、销毁以及是否可能导致 OOM。</p></blockquote><blockquote><p> <code>Loom</code>项目里<code>Fiber</code>实现了java轻量级线程(用户态)   官网 <a href="https://wiki.openjdk.java.net/display/loom" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/loom</a> </p></blockquote><h1 id="7-Worker-Thread模式"><a href="#7-Worker-Thread模式" class="headerlink" title="(7) Worker Thread模式"></a>(7) Worker Thread模式</h1><blockquote><p> Worker Thread 模式类比的是工厂里车间工人的工作模式。</p></blockquote><blockquote><p> Worker Thread 模式能避免线程频繁创建、销毁的问题，而且能够限制线程的最大数量。</p></blockquote><blockquote><p> Java 语言里可以直接使用线程池来实现 Worker Thread 模式。<br> Worker Thread 模式的实现，需要注意潜在的线程死锁问题。<br> 共享线程池虽然能够提供线程池的使用效率，但一定要保证一个前提，那就是：任务之间没有依赖关系。</p></blockquote><h1 id="8-两阶段终止模式"><a href="#8-两阶段终止模式" class="headerlink" title="(8) 两阶段终止模式"></a>(8) 两阶段终止模式</h1><blockquote><p> 两阶段终止模式。顾名思义，就是将终止过程分成两个阶段，其中第一个阶段主要是线程 T1 向线程 T2发送终止指令，而第二阶段则是线程 T2响应终止指令。</p></blockquote><blockquote><p> Java 线程进入终止状态的前提是线程进入 RUNNABLE 状态，而实际上线程也可能处在休眠状态，也就是说，我们要想终止一个线程，首先要把线程的状态从休眠状态转换到 RUNNABLE 状态。<br> 如何做到呢？这个要靠 Java Thread 类提供的 interrupt() 方法，它可以将休眠状态的线程转换到 RUNNABLE 状态。<br> 线程转换到 RUNNABLE 状态之后，我们如何再将其终止呢？<br> RUNNABLE 状态转换到终止状态，优雅的方式是让 Java 线程自己执行完 run() 方法，所以一般我们采用的方法是设置一个标志位，然后线程会在合适的时机检查这个标志位，如果发现符合终止条件，则自动退出 run() 方法。<br>这个过程其实就是我们前面提到的第二阶段：响应终止指令。<br>综合上面这两点，我们能总结出终止指令，其实包括两方面内容：interrupt()方法和线程终止的标志位。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//线程终止标志位</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> terminated = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//采集线程</span></span><br><span class="line">  Thread rptThread;</span><br><span class="line">  <span class="comment">//启动采集功能</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//不允许同时启动多个采集线程</span></span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">    terminated = <span class="keyword">false</span>;</span><br><span class="line">    rptThread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span> (!terminated)&#123;</span><br><span class="line">        <span class="comment">//省略采集、回传实现</span></span><br><span class="line">        report();</span><br><span class="line">        <span class="comment">//每隔两秒钟采集、回传一次数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">          <span class="comment">//重新设置线程中断状态</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行到此处说明线程马上终止</span></span><br><span class="line">      started = <span class="keyword">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    rptThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//终止采集功能</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置中断标志位</span></span><br><span class="line">    terminated = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//中断线程rptThread</span></span><br><span class="line">    rptThread.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> Java 领域用的最多的还是线程池，而不是手动地创建线程。那我们该如何优雅地终止线程池呢？<br> shutdown() 方法是一种很保守的关闭线程池的方法。线程池执行 shutdown() 后，就会拒绝接收新的任务，但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完之后才最终关闭线程池。<br> 而 shutdownNow() 方法，相对就激进一些了，线程池执行 shutdownNow() 后，会拒绝接收新的任务，同时还会中断线程池中正在执行的任务，已经进入阻塞队列的任务也被剥夺了执行的机会，不过这些被剥夺执行机会的任务会作为 shutdownNow() 方法的返回值返回。</p></blockquote><h1 id="9-生产者-消费者模式"><a href="#9-生产者-消费者模式" class="headerlink" title="(9) 生产者-消费者模式"></a>(9) 生产者-消费者模式</h1><blockquote><p> 从架构设计的角度来看，生产者 - 消费者模式有一个很重要的优点，就是解耦。<br> 生产者 - 消费者模式还有一个重要的优点就是支持异步，并且能够平衡生产者和消费者的速度差异。</p></blockquote><blockquote><p> Java 线程池本质上就是用生产者 - 消费者模式实现的，所以每当使用线程池的时候，其实就是在应用生产者 - 消费者模式。</p></blockquote><blockquote><p> 线程池终止指定线程<br> 线程池在消费到毒丸时知道需要结束，将方法执行完，break循环体。</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://time.geekbang.org/column/article/92856" target="_blank" rel="noopener">28 | Immutability模式：如何利用不变性解决并发问题？</a><br>[2] <a href="https://time.geekbang.org/column/article/93154" target="_blank" rel="noopener">29 | Copy-on-Write模式：不是延时策略的COW</a><br>[3] <a href="https://time.geekbang.org/column/article/93745" target="_blank" rel="noopener">30 | 线程本地存储模式：没有共享，就没有伤害</a><br>[4] <a href="https://time.geekbang.org/column/article/94097" target="_blank" rel="noopener">31 | Guarded Suspension模式：等待唤醒机制的规范实现</a><br>[5] <a href="https://time.geekbang.org/column/article/94604" target="_blank" rel="noopener">32 | Balking模式：再谈线程安全的单例模式</a><br>[6] <a href="https://time.geekbang.org/column/article/95098" target="_blank" rel="noopener">33 | Thread-Per-Message模式：最简单实用的分工方法</a><br>[7] <a href="https://time.geekbang.org/column/article/95525" target="_blank" rel="noopener">34 | Worker Thread模式：如何避免重复创建线程？</a><br>[8] <a href="https://time.geekbang.org/column/article/95847" target="_blank" rel="noopener">35 | 两阶段终止模式：如何优雅地终止线程？</a><br>[9] <a href="https://time.geekbang.org/column/article/96168" target="_blank" rel="noopener">36 | 生产者-消费者模式：用流水线思想提高效率</a><br>[10] <a href="https://time.geekbang.org/column/article/96736" target="_blank" rel="noopener">37 | 设计模式模块热点问题答疑</a><br>[11] 《图解 Java 多线程设计模式》 </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 多线程设计模式是前人解决并发问题的经验总结，当我们试图解决一个并发问题时，首选方案往往是使用匹配的设计模式，这样能避免走弯路。&lt;br&gt; 大家都熟悉设计模式，所以使用设计模式还能提升方案和代码的可理解性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;避免共享的设计模式&lt;br&gt;&lt;code&gt;Immutability 模式&lt;/code&gt;、&lt;code&gt;Copy-on-Write 模式&lt;/code&gt; 和 &lt;code&gt;线程本地存储模式&lt;/code&gt; 本质上都是为了避免共享，只是实现手段不同而已。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 多线程版本IF的设计模式&lt;br&gt; &lt;code&gt;Guarded Suspension 模式&lt;/code&gt; 和 &lt;code&gt;Balking 模式&lt;/code&gt; 都可以简单地理解为“多线程版本的 if”，但它们的区别在于前者会等待 if 条件变为真，而后者则不需要等待。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 三种最简单的分工模式&lt;br&gt; &lt;code&gt;Thread-Per-Message模式&lt;/code&gt; 、 &lt;code&gt;Worker Thread 模式&lt;/code&gt; 和 &lt;code&gt;生产者-消费者模式&lt;/code&gt; 是三种最简单实用的多线程分工方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-Immutability-Pattern-不变性模式&quot;&gt;&lt;a href=&quot;#1-Immutability-Pattern-不变性模式&quot; class=&quot;headerlink&quot; title=&quot;(1) Immutability Pattern 不变性模式&quot;&gt;&lt;/a&gt;(1) Immutability Pattern 不变性模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 不变性（Immutability）模式。所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Java SDK 里很多类都具备不可变性。例如经常用到的 String 和 Long、Integer、Double 等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。仔细翻看这些类的声明、属性和方法，你会发现它们都严格遵守不可变类的三点要求：类和属性都是 final 的，所有方法均是只读的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Java所有的基础类型的包装类都不适合做锁，因为它们内部用到了享元模式，这会导致看上去私有的锁，其实是共有的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 使用 Immutability 模式的注意事项在使用 Immutability 模式的时候，需要注意以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象的所有属性都是 final 的，并不能保证不可变性；&lt;/li&gt;
&lt;li&gt;不可变对象也需要正确发布。 &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 在使用 Immutability 模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性。&lt;br&gt; Foo对象是不变的，但是Foo对象的属性是可以变化的&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; name=&lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Bar&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Foo foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo.age=a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://weikeqin.com/categories/java/"/>
    
    
      <category term="java" scheme="http://weikeqin.com/tags/java/"/>
    
      <category term="pattern" scheme="http://weikeqin.com/tags/pattern/"/>
    
  </entry>
  
</feed>
